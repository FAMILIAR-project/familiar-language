/*
 * generated by Xtext 2.9.1
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.fml.AddConstraint;
import org.xtext.example.mydsl.fml.Aggregate;
import org.xtext.example.mydsl.fml.AggregateMerge;
import org.xtext.example.mydsl.fml.AlternativeEdit;
import org.xtext.example.mydsl.fml.AnalysisOperation;
import org.xtext.example.mydsl.fml.AncestorFeature;
import org.xtext.example.mydsl.fml.And_expr;
import org.xtext.example.mydsl.fml.AsFM;
import org.xtext.example.mydsl.fml.Assertion;
import org.xtext.example.mydsl.fml.AtomicConstraintExpr;
import org.xtext.example.mydsl.fml.AutoConfiguration;
import org.xtext.example.mydsl.fml.Biimpl_expr;
import org.xtext.example.mydsl.fml.BoolOperation;
import org.xtext.example.mydsl.fml.BooleanExpr;
import org.xtext.example.mydsl.fml.CNFExpression;
import org.xtext.example.mydsl.fml.CTCRCommand;
import org.xtext.example.mydsl.fml.ChildrenFeature;
import org.xtext.example.mydsl.fml.CleanUp;
import org.xtext.example.mydsl.fml.Cliques;
import org.xtext.example.mydsl.fml.Compare;
import org.xtext.example.mydsl.fml.ComparisonOperation;
import org.xtext.example.mydsl.fml.CompleteConfiguration;
import org.xtext.example.mydsl.fml.ComplexCommand;
import org.xtext.example.mydsl.fml.ComputeConstraints;
import org.xtext.example.mydsl.fml.ComputeFGroups;
import org.xtext.example.mydsl.fml.ConstraintExpr;
import org.xtext.example.mydsl.fml.ConstraintsSpecification;
import org.xtext.example.mydsl.fml.Convert;
import org.xtext.example.mydsl.fml.CopyVariable;
import org.xtext.example.mydsl.fml.Cores;
import org.xtext.example.mydsl.fml.CreateConfiguration;
import org.xtext.example.mydsl.fml.Deads;
import org.xtext.example.mydsl.fml.Dependency;
import org.xtext.example.mydsl.fml.DescendantFeature;
import org.xtext.example.mydsl.fml.DeselectedConfiguration;
import org.xtext.example.mydsl.fml.Exist;
import org.xtext.example.mydsl.fml.Exit;
import org.xtext.example.mydsl.fml.Export;
import org.xtext.example.mydsl.fml.Extract;
import org.xtext.example.mydsl.fml.FMFeature;
import org.xtext.example.mydsl.fml.FMLSave;
import org.xtext.example.mydsl.fml.FamiliarScript;
import org.xtext.example.mydsl.fml.FeatureExpression;
import org.xtext.example.mydsl.fml.FeatureModel;
import org.xtext.example.mydsl.fml.FeatureOperation;
import org.xtext.example.mydsl.fml.FeatureOperator;
import org.xtext.example.mydsl.fml.FeatureVariabilityOperator;
import org.xtext.example.mydsl.fml.FmlPackage;
import org.xtext.example.mydsl.fml.ForeachSet;
import org.xtext.example.mydsl.fml.FullMandatorys;
import org.xtext.example.mydsl.fml.GDisplay;
import org.xtext.example.mydsl.fml.GListing;
import org.xtext.example.mydsl.fml.GetConstraints;
import org.xtext.example.mydsl.fml.GetFGroups;
import org.xtext.example.mydsl.fml.GroupsSpecification;
import org.xtext.example.mydsl.fml.HProduction;
import org.xtext.example.mydsl.fml.Hidden;
import org.xtext.example.mydsl.fml.Hierarchy;
import org.xtext.example.mydsl.fml.HierarchySpecification;
import org.xtext.example.mydsl.fml.IdentifierExpr;
import org.xtext.example.mydsl.fml.IfCondition;
import org.xtext.example.mydsl.fml.Impl_expr;
import org.xtext.example.mydsl.fml.Insert;
import org.xtext.example.mydsl.fml.IntLiteral;
import org.xtext.example.mydsl.fml.IntegerOperation;
import org.xtext.example.mydsl.fml.IsConflicting;
import org.xtext.example.mydsl.fml.IsEmptySet;
import org.xtext.example.mydsl.fml.KnowledgeSpecification;
import org.xtext.example.mydsl.fml.LArgs;
import org.xtext.example.mydsl.fml.LFMArgs;
import org.xtext.example.mydsl.fml.LVidentifier;
import org.xtext.example.mydsl.fml.Leaves;
import org.xtext.example.mydsl.fml.Listing;
import org.xtext.example.mydsl.fml.LoadGeneric;
import org.xtext.example.mydsl.fml.Mandatory;
import org.xtext.example.mydsl.fml.MandatoryEdit;
import org.xtext.example.mydsl.fml.Map;
import org.xtext.example.mydsl.fml.Merge;
import org.xtext.example.mydsl.fml.MtxGroupSpec;
import org.xtext.example.mydsl.fml.Mutexgroup;
import org.xtext.example.mydsl.fml.NameFeature;
import org.xtext.example.mydsl.fml.Neg_expr;
import org.xtext.example.mydsl.fml.Optional;
import org.xtext.example.mydsl.fml.OptionalEdit;
import org.xtext.example.mydsl.fml.OrEdit;
import org.xtext.example.mydsl.fml.OrGroupSpec;
import org.xtext.example.mydsl.fml.Or_expr;
import org.xtext.example.mydsl.fml.Orgroup;
import org.xtext.example.mydsl.fml.PairwiseCommand;
import org.xtext.example.mydsl.fml.ParentFeature;
import org.xtext.example.mydsl.fml.PrinterUtility;
import org.xtext.example.mydsl.fml.Production;
import org.xtext.example.mydsl.fml.RemoveConstraint;
import org.xtext.example.mydsl.fml.RemoveFeature;
import org.xtext.example.mydsl.fml.RemoveVariable;
import org.xtext.example.mydsl.fml.RenameFeature;
import org.xtext.example.mydsl.fml.ScriptCommand;
import org.xtext.example.mydsl.fml.ScriptDefinition;
import org.xtext.example.mydsl.fml.SelectedConfiguration;
import org.xtext.example.mydsl.fml.SelectionFeature;
import org.xtext.example.mydsl.fml.SetAddOrRemove;
import org.xtext.example.mydsl.fml.SetBelongs;
import org.xtext.example.mydsl.fml.SetCard;
import org.xtext.example.mydsl.fml.SetEmpty;
import org.xtext.example.mydsl.fml.SetExpr;
import org.xtext.example.mydsl.fml.SetOperation;
import org.xtext.example.mydsl.fml.SetToNames;
import org.xtext.example.mydsl.fml.SetUnionOrIntersection;
import org.xtext.example.mydsl.fml.Shell;
import org.xtext.example.mydsl.fml.SiblingFeature;
import org.xtext.example.mydsl.fml.Slice;
import org.xtext.example.mydsl.fml.State;
import org.xtext.example.mydsl.fml.StringConcat;
import org.xtext.example.mydsl.fml.StringExpr;
import org.xtext.example.mydsl.fml.StringIndexOf;
import org.xtext.example.mydsl.fml.StringInit;
import org.xtext.example.mydsl.fml.StringLength;
import org.xtext.example.mydsl.fml.StringSubstring;
import org.xtext.example.mydsl.fml.Synthesis;
import org.xtext.example.mydsl.fml.UnMap;
import org.xtext.example.mydsl.fml.UnselectedConfiguration;
import org.xtext.example.mydsl.fml.VariableNull;
import org.xtext.example.mydsl.fml.XorGroupSpec;
import org.xtext.example.mydsl.fml.Xorgroup;
import org.xtext.example.mydsl.fml.lType;
import org.xtext.example.mydsl.services.FmlGrammarAccess;

@SuppressWarnings("all")
public class FmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FmlPackage.ADD_CONSTRAINT:
				sequence_AddConstraint(context, (AddConstraint) semanticObject); 
				return; 
			case FmlPackage.AGGREGATE:
				sequence_Aggregate(context, (Aggregate) semanticObject); 
				return; 
			case FmlPackage.AGGREGATE_MERGE:
				sequence_AggregateMerge(context, (AggregateMerge) semanticObject); 
				return; 
			case FmlPackage.ALTERNATIVE_EDIT:
				sequence_AlternativeEdit(context, (AlternativeEdit) semanticObject); 
				return; 
			case FmlPackage.ANALYSIS_OPERATION:
				sequence_AnalysisOperation(context, (AnalysisOperation) semanticObject); 
				return; 
			case FmlPackage.ANCESTOR_FEATURE:
				sequence_AncestorFeature(context, (AncestorFeature) semanticObject); 
				return; 
			case FmlPackage.AND_EXPR:
				sequence_And_expr(context, (And_expr) semanticObject); 
				return; 
			case FmlPackage.AS_FM:
				sequence_AsFM(context, (AsFM) semanticObject); 
				return; 
			case FmlPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case FmlPackage.ATOMIC_CONSTRAINT_EXPR:
				sequence_AtomicConstraintExpr(context, (AtomicConstraintExpr) semanticObject); 
				return; 
			case FmlPackage.AUTO_CONFIGURATION:
				sequence_AutoConfiguration(context, (AutoConfiguration) semanticObject); 
				return; 
			case FmlPackage.BIIMPL_EXPR:
				sequence_Biimpl_expr(context, (Biimpl_expr) semanticObject); 
				return; 
			case FmlPackage.BOOL_OPERATION:
				sequence_ComplexCommand(context, (BoolOperation) semanticObject); 
				return; 
			case FmlPackage.BOOLEAN_EXPR:
				sequence_BooleanExpr(context, (BooleanExpr) semanticObject); 
				return; 
			case FmlPackage.CNF_EXPRESSION:
				sequence_Primary_expr(context, (CNFExpression) semanticObject); 
				return; 
			case FmlPackage.CTCR_COMMAND:
				sequence_CTCRCommand(context, (CTCRCommand) semanticObject); 
				return; 
			case FmlPackage.CHILDREN_FEATURE:
				sequence_ChildrenFeature(context, (ChildrenFeature) semanticObject); 
				return; 
			case FmlPackage.CLEAN_UP:
				sequence_CleanUp(context, (CleanUp) semanticObject); 
				return; 
			case FmlPackage.CLIQUES:
				sequence_Cliques(context, (Cliques) semanticObject); 
				return; 
			case FmlPackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case FmlPackage.COMPARISON_OPERATION:
				sequence_ComplexCommand(context, (ComparisonOperation) semanticObject); 
				return; 
			case FmlPackage.COMPLETE_CONFIGURATION:
				sequence_CompleteConfiguration(context, (CompleteConfiguration) semanticObject); 
				return; 
			case FmlPackage.COMPLEX_COMMAND:
				if (action == grammarAccess.getComplexCommandAccess().getIntegerOperationLeftAction_0_1_0_0()
						|| action == grammarAccess.getComplexCommandAccess().getBoolOperationLeftAction_0_1_1_0()
						|| action == grammarAccess.getComplexCommandAccess().getComparisonOperationLeftAction_0_1_2_0()
						|| action == grammarAccess.getComplexCommandAccess().getSetOperationLeftAction_0_1_3_0()) {
					sequence_ComplexCommand_BoolOperation_0_1_1_0_ComparisonOperation_0_1_2_0_IntegerOperation_0_1_0_0_SetOperation_0_1_3_0(context, (ComplexCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getScriptCommandRule()
						|| rule == grammarAccess.getComplexCommandRule()
						|| rule == grammarAccess.getCommandRule()
						|| rule == grammarAccess.getFMLAbstractCommandRule()) {
					sequence_ComplexCommand(context, (ComplexCommand) semanticObject); 
					return; 
				}
				else break;
			case FmlPackage.COMPUTE_CONSTRAINTS:
				sequence_ComputeConstraints(context, (ComputeConstraints) semanticObject); 
				return; 
			case FmlPackage.COMPUTE_FGROUPS:
				sequence_ComputeFGroups(context, (ComputeFGroups) semanticObject); 
				return; 
			case FmlPackage.CONSTRAINT_EXPR:
				sequence_ConstraintExpr(context, (ConstraintExpr) semanticObject); 
				return; 
			case FmlPackage.CONSTRAINTS_SPECIFICATION:
				sequence_ConstraintsSpecification(context, (ConstraintsSpecification) semanticObject); 
				return; 
			case FmlPackage.CONVERT:
				sequence_Convert(context, (Convert) semanticObject); 
				return; 
			case FmlPackage.COPY_VARIABLE:
				sequence_CopyVariable(context, (CopyVariable) semanticObject); 
				return; 
			case FmlPackage.CORES:
				sequence_Cores(context, (Cores) semanticObject); 
				return; 
			case FmlPackage.CREATE_CONFIGURATION:
				sequence_CreateConfiguration(context, (CreateConfiguration) semanticObject); 
				return; 
			case FmlPackage.DEADS:
				sequence_Deads(context, (Deads) semanticObject); 
				return; 
			case FmlPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case FmlPackage.DESCENDANT_FEATURE:
				sequence_DescendantFeature(context, (DescendantFeature) semanticObject); 
				return; 
			case FmlPackage.DESELECTED_CONFIGURATION:
				sequence_DeselectedConfiguration(context, (DeselectedConfiguration) semanticObject); 
				return; 
			case FmlPackage.EXIST:
				sequence_Exist(context, (Exist) semanticObject); 
				return; 
			case FmlPackage.EXIT:
				sequence_Exit(context, (Exit) semanticObject); 
				return; 
			case FmlPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case FmlPackage.EXTRACT:
				sequence_Extract(context, (Extract) semanticObject); 
				return; 
			case FmlPackage.FM_FEATURE:
				sequence_FMFeature(context, (FMFeature) semanticObject); 
				return; 
			case FmlPackage.FML_SAVE:
				sequence_FMLSave(context, (FMLSave) semanticObject); 
				return; 
			case FmlPackage.FAMILIAR_SCRIPT:
				sequence_FamiliarScript(context, (FamiliarScript) semanticObject); 
				return; 
			case FmlPackage.FEATURE_EXPRESSION:
				sequence_FeatureExpression(context, (FeatureExpression) semanticObject); 
				return; 
			case FmlPackage.FEATURE_MODEL:
				sequence_FeatureModel(context, (FeatureModel) semanticObject); 
				return; 
			case FmlPackage.FEATURE_OPERATION:
				sequence_FeatureOperation(context, (FeatureOperation) semanticObject); 
				return; 
			case FmlPackage.FEATURE_OPERATOR:
				sequence_FeatureOperator(context, (FeatureOperator) semanticObject); 
				return; 
			case FmlPackage.FEATURE_VARIABILITY_OPERATOR:
				sequence_FeatureVariabilityOperator(context, (FeatureVariabilityOperator) semanticObject); 
				return; 
			case FmlPackage.FOREACH_SET:
				sequence_ForeachSet(context, (ForeachSet) semanticObject); 
				return; 
			case FmlPackage.FULL_MANDATORYS:
				sequence_FullMandatorys(context, (FullMandatorys) semanticObject); 
				return; 
			case FmlPackage.GDISPLAY:
				sequence_GDisplay(context, (GDisplay) semanticObject); 
				return; 
			case FmlPackage.GLISTING:
				sequence_GListing(context, (GListing) semanticObject); 
				return; 
			case FmlPackage.GET_CONSTRAINTS:
				sequence_GetConstraints(context, (GetConstraints) semanticObject); 
				return; 
			case FmlPackage.GET_FGROUPS:
				sequence_GetFGroups(context, (GetFGroups) semanticObject); 
				return; 
			case FmlPackage.GROUPS_SPECIFICATION:
				sequence_GroupsSpecification(context, (GroupsSpecification) semanticObject); 
				return; 
			case FmlPackage.HPRODUCTION:
				sequence_HProduction(context, (HProduction) semanticObject); 
				return; 
			case FmlPackage.HIDDEN:
				sequence_Hidden(context, (Hidden) semanticObject); 
				return; 
			case FmlPackage.HIERARCHY:
				sequence_Hierarchy(context, (Hierarchy) semanticObject); 
				return; 
			case FmlPackage.HIERARCHY_SPECIFICATION:
				sequence_HierarchySpecification(context, (HierarchySpecification) semanticObject); 
				return; 
			case FmlPackage.IDENTIFIER_EXPR:
				sequence_IdentifierExpr(context, (IdentifierExpr) semanticObject); 
				return; 
			case FmlPackage.IF_CONDITION:
				sequence_IfCondition(context, (IfCondition) semanticObject); 
				return; 
			case FmlPackage.IMPL_EXPR:
				sequence_Impl_expr(context, (Impl_expr) semanticObject); 
				return; 
			case FmlPackage.INSERT:
				sequence_Insert(context, (Insert) semanticObject); 
				return; 
			case FmlPackage.INT_LITERAL:
				sequence_IntegerExpr(context, (IntLiteral) semanticObject); 
				return; 
			case FmlPackage.INTEGER_OPERATION:
				sequence_ComplexCommand(context, (IntegerOperation) semanticObject); 
				return; 
			case FmlPackage.IS_CONFLICTING:
				sequence_IsConflicting(context, (IsConflicting) semanticObject); 
				return; 
			case FmlPackage.IS_EMPTY_SET:
				sequence_IsEmptySet(context, (IsEmptySet) semanticObject); 
				return; 
			case FmlPackage.KNOWLEDGE_SPECIFICATION:
				sequence_KnowledgeSpecification(context, (KnowledgeSpecification) semanticObject); 
				return; 
			case FmlPackage.LARGS:
				sequence_LArgs(context, (LArgs) semanticObject); 
				return; 
			case FmlPackage.LFM_ARGS:
				sequence_LFMArgs(context, (LFMArgs) semanticObject); 
				return; 
			case FmlPackage.LVIDENTIFIER:
				sequence_LVidentifier(context, (LVidentifier) semanticObject); 
				return; 
			case FmlPackage.LEAVES:
				sequence_Leaves(context, (Leaves) semanticObject); 
				return; 
			case FmlPackage.LISTING:
				sequence_Listing(context, (Listing) semanticObject); 
				return; 
			case FmlPackage.LOAD_GENERIC:
				sequence_LoadGeneric(context, (LoadGeneric) semanticObject); 
				return; 
			case FmlPackage.MANDATORY:
				sequence_Mandatory(context, (Mandatory) semanticObject); 
				return; 
			case FmlPackage.MANDATORY_EDIT:
				sequence_MandatoryEdit(context, (MandatoryEdit) semanticObject); 
				return; 
			case FmlPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case FmlPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case FmlPackage.MTX_GROUP_SPEC:
				sequence_MtxGroupSpec(context, (MtxGroupSpec) semanticObject); 
				return; 
			case FmlPackage.MUTEXGROUP:
				sequence_Mutexgroup(context, (Mutexgroup) semanticObject); 
				return; 
			case FmlPackage.NAME_FEATURE:
				sequence_NameFeature(context, (NameFeature) semanticObject); 
				return; 
			case FmlPackage.NEG_EXPR:
				sequence_Neg_expr(context, (Neg_expr) semanticObject); 
				return; 
			case FmlPackage.OPTIONAL:
				sequence_Optional(context, (Optional) semanticObject); 
				return; 
			case FmlPackage.OPTIONAL_EDIT:
				sequence_OptionalEdit(context, (OptionalEdit) semanticObject); 
				return; 
			case FmlPackage.OR_EDIT:
				sequence_OrEdit(context, (OrEdit) semanticObject); 
				return; 
			case FmlPackage.OR_GROUP_SPEC:
				sequence_OrGroupSpec(context, (OrGroupSpec) semanticObject); 
				return; 
			case FmlPackage.OR_EXPR:
				sequence_Or_expr(context, (Or_expr) semanticObject); 
				return; 
			case FmlPackage.ORGROUP:
				sequence_Orgroup(context, (Orgroup) semanticObject); 
				return; 
			case FmlPackage.PAIRWISE_COMMAND:
				sequence_PairwiseCommand(context, (PairwiseCommand) semanticObject); 
				return; 
			case FmlPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.example.mydsl.fml.Parameter) semanticObject); 
				return; 
			case FmlPackage.PARENT_FEATURE:
				sequence_ParentFeature(context, (ParentFeature) semanticObject); 
				return; 
			case FmlPackage.PRINTER_UTILITY:
				sequence_PrinterUtility(context, (PrinterUtility) semanticObject); 
				return; 
			case FmlPackage.PRODUCTION:
				sequence_Production(context, (Production) semanticObject); 
				return; 
			case FmlPackage.REMOVE_CONSTRAINT:
				sequence_RemoveConstraint(context, (RemoveConstraint) semanticObject); 
				return; 
			case FmlPackage.REMOVE_FEATURE:
				sequence_RemoveFeature(context, (RemoveFeature) semanticObject); 
				return; 
			case FmlPackage.REMOVE_VARIABLE:
				sequence_RemoveVariable(context, (RemoveVariable) semanticObject); 
				return; 
			case FmlPackage.RENAME_FEATURE:
				sequence_RenameFeature(context, (RenameFeature) semanticObject); 
				return; 
			case FmlPackage.SCRIPT_COMMAND:
				sequence_ScriptCommand(context, (ScriptCommand) semanticObject); 
				return; 
			case FmlPackage.SCRIPT_DEFINITION:
				sequence_ScriptDefinition(context, (ScriptDefinition) semanticObject); 
				return; 
			case FmlPackage.SELECTED_CONFIGURATION:
				sequence_SelectedConfiguration(context, (SelectedConfiguration) semanticObject); 
				return; 
			case FmlPackage.SELECTION_FEATURE:
				sequence_SelectionFeature(context, (SelectionFeature) semanticObject); 
				return; 
			case FmlPackage.SET_ADD_OR_REMOVE:
				sequence_SetAddOrRemove(context, (SetAddOrRemove) semanticObject); 
				return; 
			case FmlPackage.SET_BELONGS:
				sequence_SetBelongs(context, (SetBelongs) semanticObject); 
				return; 
			case FmlPackage.SET_CARD:
				sequence_SetCard(context, (SetCard) semanticObject); 
				return; 
			case FmlPackage.SET_EMPTY:
				sequence_SetEmpty(context, (SetEmpty) semanticObject); 
				return; 
			case FmlPackage.SET_EXPR:
				sequence_SetExpr(context, (SetExpr) semanticObject); 
				return; 
			case FmlPackage.SET_OPERATION:
				sequence_ComplexCommand(context, (SetOperation) semanticObject); 
				return; 
			case FmlPackage.SET_TO_NAMES:
				sequence_SetToNames(context, (SetToNames) semanticObject); 
				return; 
			case FmlPackage.SET_UNION_OR_INTERSECTION:
				sequence_SetUnionOrIntersection(context, (SetUnionOrIntersection) semanticObject); 
				return; 
			case FmlPackage.SHELL:
				sequence_Shell(context, (Shell) semanticObject); 
				return; 
			case FmlPackage.SIBLING_FEATURE:
				sequence_SiblingFeature(context, (SiblingFeature) semanticObject); 
				return; 
			case FmlPackage.SLICE:
				sequence_Slice(context, (Slice) semanticObject); 
				return; 
			case FmlPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case FmlPackage.STRING_CONCAT:
				sequence_StringConcat(context, (StringConcat) semanticObject); 
				return; 
			case FmlPackage.STRING_EXPR:
				sequence_StringExpr(context, (StringExpr) semanticObject); 
				return; 
			case FmlPackage.STRING_INDEX_OF:
				sequence_StringIndexOf(context, (StringIndexOf) semanticObject); 
				return; 
			case FmlPackage.STRING_INIT:
				sequence_StringInit(context, (StringInit) semanticObject); 
				return; 
			case FmlPackage.STRING_LENGTH:
				sequence_StringLength(context, (StringLength) semanticObject); 
				return; 
			case FmlPackage.STRING_SUBSTRING:
				sequence_StringSubstring(context, (StringSubstring) semanticObject); 
				return; 
			case FmlPackage.SYNTHESIS:
				sequence_Synthesis(context, (Synthesis) semanticObject); 
				return; 
			case FmlPackage.UN_MAP:
				sequence_UnMap(context, (UnMap) semanticObject); 
				return; 
			case FmlPackage.UNSELECTED_CONFIGURATION:
				sequence_UnselectedConfiguration(context, (UnselectedConfiguration) semanticObject); 
				return; 
			case FmlPackage.VARIABLE_NULL:
				sequence_VariableNull(context, (VariableNull) semanticObject); 
				return; 
			case FmlPackage.XOR_GROUP_SPEC:
				sequence_XorGroupSpec(context, (XorGroupSpec) semanticObject); 
				return; 
			case FmlPackage.XORGROUP:
				sequence_Xorgroup(context, (Xorgroup) semanticObject); 
				return; 
			case FmlPackage.LTYPE:
				sequence_lType(context, (lType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Command returns AddConstraint
	 *     FMLAbstractCommand returns AddConstraint
	 *     AddConstraint returns AddConstraint
	 *
	 * Constraint:
	 *     (cst=ConstraintCommand fm=FMCommand)
	 */
	protected void sequence_AddConstraint(ISerializationContext context, AddConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAddConstraint_Cst()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAddConstraint_Cst()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAddConstraint_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAddConstraint_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddConstraintAccess().getCstConstraintCommandParserRuleCall_1_0(), semanticObject.getCst());
		feeder.accept(grammarAccess.getAddConstraintAccess().getFmFMCommandParserRuleCall_3_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AggregateMerge
	 *     FMLAbstractCommand returns AggregateMerge
	 *     FMCommand returns AggregateMerge
	 *     AggregateMerge returns AggregateMerge
	 *
	 * Constraint:
	 *     ((hierarchySpecified?='--hierarchy' hierarchyStrategy=HierarchyStrategy)? mode=MergeMode (lfms+=FMCommand+ | fms=LFMArgs))
	 */
	protected void sequence_AggregateMerge(ISerializationContext context, AggregateMerge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Aggregate
	 *     FMLAbstractCommand returns Aggregate
	 *     FMCommand returns Aggregate
	 *     Aggregate returns Aggregate
	 *
	 * Constraint:
	 *     (renamings?='--renamings'? (fms+=FMCommand+ | sfms=IdentifierExpr) mapping=SetCommand?)
	 */
	protected void sequence_Aggregate(ISerializationContext context, Aggregate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AlternativeEdit
	 *     FMLAbstractCommand returns AlternativeEdit
	 *     BCommand returns AlternativeEdit
	 *     ModifyVOperator returns AlternativeEdit
	 *     AlternativeEdit returns AlternativeEdit
	 *
	 * Constraint:
	 *     fts=SetCommand
	 */
	protected void sequence_AlternativeEdit(ISerializationContext context, AlternativeEdit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAlternativeEdit_Fts()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAlternativeEdit_Fts()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlternativeEditAccess().getFtsSetCommandParserRuleCall_1_0(), semanticObject.getFts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AnalysisOperation
	 *     FMLAbstractCommand returns AnalysisOperation
	 *     AnalysisOperation returns AnalysisOperation
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             op='isValid' | 
	 *             op='counting' | 
	 *             op='configs' | 
	 *             op='nbFeatures' | 
	 *             op='root' | 
	 *             op='features'
	 *         ) 
	 *         (fm=FMCommand | fm=ConfigurationCommand)
	 *     )
	 */
	protected void sequence_AnalysisOperation(ISerializationContext context, AnalysisOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AncestorFeature returns AncestorFeature
	 *
	 * Constraint:
	 *     val='ancestors'
	 */
	protected void sequence_AncestorFeature(ISerializationContext context, AncestorFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAncestorFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAncestorFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAncestorFeatureAccess().getValAncestorsKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns And_expr
	 *     Or_expr returns And_expr
	 *     Or_expr.Or_expr_1_0 returns And_expr
	 *     And_expr returns And_expr
	 *     And_expr.And_expr_1_0 returns And_expr
	 *     Impl_expr returns And_expr
	 *     Impl_expr.Impl_expr_1_0 returns And_expr
	 *     Biimpl_expr returns And_expr
	 *     Biimpl_expr.Biimpl_expr_1_0 returns And_expr
	 *     Unary_expr returns And_expr
	 *     Primary_expr returns And_expr
	 *
	 * Constraint:
	 *     (left=And_expr_And_expr_1_0 right=Impl_expr)
	 */
	protected void sequence_And_expr(ISerializationContext context, And_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAnd_expr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAnd_expr_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAnd_expr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAnd_expr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_exprAccess().getRightImpl_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AsFM
	 *     FMLAbstractCommand returns AsFM
	 *     FMCommand returns AsFM
	 *     AsFM returns AsFM
	 *
	 * Constraint:
	 *     conf=ConfigurationCommand
	 */
	protected void sequence_AsFM(ISerializationContext context, AsFM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAsFM_Conf()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAsFM_Conf()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsFMAccess().getConfConfigurationCommandParserRuleCall_1_0(), semanticObject.getConf());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Assertion
	 *     FMLAbstractCommand returns Assertion
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     assertion=ComplexCommand
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAssertion_Assertion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAssertion_Assertion()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionAccess().getAssertionComplexCommandParserRuleCall_2_0(), semanticObject.getAssertion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AtomicConstraintExpr
	 *     AtomicConstraintExpr returns AtomicConstraintExpr
	 *     FMLAbstractCommand returns AtomicConstraintExpr
	 *     ConstraintCommand returns AtomicConstraintExpr
	 *
	 * Constraint:
	 *     expr=CNF
	 */
	protected void sequence_AtomicConstraintExpr(ISerializationContext context, AtomicConstraintExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getAtomicConstraintExpr_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getAtomicConstraintExpr_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicConstraintExprAccess().getExprCNFParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns AutoConfiguration
	 *     FMLAbstractCommand returns AutoConfiguration
	 *     ConfigurationCmd returns AutoConfiguration
	 *     AutoConfiguration returns AutoConfiguration
	 *
	 * Constraint:
	 *     (config=ConfigurationCommand mode=AutoConfMode?)
	 */
	protected void sequence_AutoConfiguration(ISerializationContext context, AutoConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns Biimpl_expr
	 *     Or_expr returns Biimpl_expr
	 *     Or_expr.Or_expr_1_0 returns Biimpl_expr
	 *     And_expr returns Biimpl_expr
	 *     And_expr.And_expr_1_0 returns Biimpl_expr
	 *     Impl_expr returns Biimpl_expr
	 *     Impl_expr.Impl_expr_1_0 returns Biimpl_expr
	 *     Biimpl_expr returns Biimpl_expr
	 *     Biimpl_expr.Biimpl_expr_1_0 returns Biimpl_expr
	 *     Unary_expr returns Biimpl_expr
	 *     Primary_expr returns Biimpl_expr
	 *
	 * Constraint:
	 *     (left=Biimpl_expr_Biimpl_expr_1_0 right=Unary_expr)
	 */
	protected void sequence_Biimpl_expr(ISerializationContext context, Biimpl_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getBiimpl_expr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getBiimpl_expr_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getBiimpl_expr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getBiimpl_expr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBiimpl_exprAccess().getBiimpl_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBiimpl_exprAccess().getRightUnary_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns BooleanExpr
	 *     BooleanExpr returns BooleanExpr
	 *     FMLAbstractCommand returns BooleanExpr
	 *
	 * Constraint:
	 *     (val='true' | val='false')
	 */
	protected void sequence_BooleanExpr(ISerializationContext context, BooleanExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CTCRCommand
	 *     FMLAbstractCommand returns CTCRCommand
	 *     IntegerCommand returns CTCRCommand
	 *     DoubleCommand returns CTCRCommand
	 *     CTCRCommand returns CTCRCommand
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_CTCRCommand(ISerializationContext context, CTCRCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCTCRCommand_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCTCRCommand_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCTCRCommandAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ChildrenFeature returns ChildrenFeature
	 *
	 * Constraint:
	 *     val='children'
	 */
	protected void sequence_ChildrenFeature(ISerializationContext context, ChildrenFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getChildrenFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getChildrenFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChildrenFeatureAccess().getValChildrenKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CleanUp
	 *     FMLAbstractCommand returns CleanUp
	 *     CleanUp returns CleanUp
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_CleanUp(ISerializationContext context, CleanUp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCleanUp_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCleanUp_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCleanUpAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Cliques
	 *     FMLAbstractCommand returns Cliques
	 *     SetCommand returns Cliques
	 *     Cliques returns Cliques
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_Cliques(ISerializationContext context, Cliques semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCliques_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCliques_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCliquesAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Compare
	 *     FMLAbstractCommand returns Compare
	 *     Compare returns Compare
	 *
	 * Constraint:
	 *     (fm_left=FMCommand fm_right=FMCommand)
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCompare_Fm_left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCompare_Fm_left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCompare_Fm_right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCompare_Fm_right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getFm_leftFMCommandParserRuleCall_1_0(), semanticObject.getFm_left());
		feeder.accept(grammarAccess.getCompareAccess().getFm_rightFMCommandParserRuleCall_2_0(), semanticObject.getFm_right());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CompleteConfiguration
	 *     FMLAbstractCommand returns CompleteConfiguration
	 *     BCommand returns CompleteConfiguration
	 *     ConfigurationCmd returns CompleteConfiguration
	 *     CompleteConfiguration returns CompleteConfiguration
	 *
	 * Constraint:
	 *     config=ConfigurationCommand
	 */
	protected void sequence_CompleteConfiguration(ISerializationContext context, CompleteConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCompleteConfiguration_Config()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCompleteConfiguration_Config()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompleteConfigurationAccess().getConfigConfigurationCommandParserRuleCall_1_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns BoolOperation
	 *     ComplexCommand returns BoolOperation
	 *     Command returns BoolOperation
	 *     FMLAbstractCommand returns BoolOperation
	 *
	 * Constraint:
	 *     (left=ComplexCommand_BoolOperation_0_1_1_0 op=BOOL_Operator right=ComplexCommand)
	 */
	protected void sequence_ComplexCommand(ISerializationContext context, BoolOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getBoolOperation_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getBoolOperation_Op()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getBoolOperation_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getBoolOperation_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexCommandAccess().getBoolOperationLeftAction_0_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComplexCommandAccess().getOpBOOL_OperatorEnumRuleCall_0_1_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComplexCommandAccess().getRightComplexCommandParserRuleCall_0_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComplexCommand.IntegerOperation_0_1_0_0 returns ComplexCommand
	 *     ComplexCommand.BoolOperation_0_1_1_0 returns ComplexCommand
	 *     ComplexCommand.ComparisonOperation_0_1_2_0 returns ComplexCommand
	 *     ComplexCommand.SetOperation_0_1_3_0 returns ComplexCommand
	 *
	 * Constraint:
	 *     left=Command
	 */
	protected void sequence_ComplexCommand_BoolOperation_0_1_1_0_ComparisonOperation_0_1_2_0_IntegerOperation_0_1_0_0_SetOperation_0_1_3_0(ISerializationContext context, ComplexCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexCommandAccess().getLeftCommandParserRuleCall_0_0_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns ComparisonOperation
	 *     ComplexCommand returns ComparisonOperation
	 *     Command returns ComparisonOperation
	 *     FMLAbstractCommand returns ComparisonOperation
	 *
	 * Constraint:
	 *     (left=ComplexCommand_ComparisonOperation_0_1_2_0 cmpOp=ComparisonOperator right=ComplexCommand)
	 */
	protected void sequence_ComplexCommand(ISerializationContext context, ComparisonOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComparisonOperation_CmpOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComparisonOperation_CmpOp()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComparisonOperation_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComparisonOperation_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexCommandAccess().getComparisonOperationLeftAction_0_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComplexCommandAccess().getCmpOpComparisonOperatorEnumRuleCall_0_1_2_1_0(), semanticObject.getCmpOp());
		feeder.accept(grammarAccess.getComplexCommandAccess().getRightComplexCommandParserRuleCall_0_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns ComplexCommand
	 *     ComplexCommand returns ComplexCommand
	 *     Command returns ComplexCommand
	 *     FMLAbstractCommand returns ComplexCommand
	 *
	 * Constraint:
	 *     (left=Command | (not?='not' batom=ComplexCommand))
	 */
	protected void sequence_ComplexCommand(ISerializationContext context, ComplexCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns IntegerOperation
	 *     ComplexCommand returns IntegerOperation
	 *     Command returns IntegerOperation
	 *     FMLAbstractCommand returns IntegerOperation
	 *
	 * Constraint:
	 *     (left=ComplexCommand_IntegerOperation_0_1_0_0 (op=PLUS | op=MINUS | op=MULT | op=DIV | op=EXP) right=IntegerCommand)
	 */
	protected void sequence_ComplexCommand(ISerializationContext context, IntegerOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns SetOperation
	 *     ComplexCommand returns SetOperation
	 *     Command returns SetOperation
	 *     FMLAbstractCommand returns SetOperation
	 *
	 * Constraint:
	 *     (left=ComplexCommand_SetOperation_0_1_3_0 sop=SetOperator right=ComplexCommand)
	 */
	protected void sequence_ComplexCommand(ISerializationContext context, SetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComplexCommand_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetOperation_Sop()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetOperation_Sop()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetOperation_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetOperation_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexCommandAccess().getSetOperationLeftAction_0_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComplexCommandAccess().getSopSetOperatorEnumRuleCall_0_1_3_1_0(), semanticObject.getSop());
		feeder.accept(grammarAccess.getComplexCommandAccess().getRightComplexCommandParserRuleCall_0_1_3_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ComputeConstraints
	 *     FMLAbstractCommand returns ComputeConstraints
	 *     SetCommand returns ComputeConstraints
	 *     ComputeConstraints returns ComputeConstraints
	 *
	 * Constraint:
	 *     (kindOfCompute=KindOfCompute fm=FMCommand (over?='over' fts=SetCommand)?)
	 */
	protected void sequence_ComputeConstraints(ISerializationContext context, ComputeConstraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ComputeFGroups
	 *     FMLAbstractCommand returns ComputeFGroups
	 *     SetCommand returns ComputeFGroups
	 *     ComputeFGroups returns ComputeFGroups
	 *
	 * Constraint:
	 *     (kindOfGroups=KindOfComputeGroups fm=FMCommand)
	 */
	protected void sequence_ComputeFGroups(ISerializationContext context, ComputeFGroups semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComputeFGroups_KindOfGroups()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComputeFGroups_KindOfGroups()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getComputeFGroups_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getComputeFGroups_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComputeFGroupsAccess().getKindOfGroupsKindOfComputeGroupsEnumRuleCall_0_0(), semanticObject.getKindOfGroups());
		feeder.accept(grammarAccess.getComputeFGroupsAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ConstraintExpr
	 *     ConstraintExpr returns ConstraintExpr
	 *     FMLAbstractCommand returns ConstraintExpr
	 *     SetCommand returns ConstraintExpr
	 *
	 * Constraint:
	 *     (constraints+=CNF+ | fm=FMCommand)
	 */
	protected void sequence_ConstraintExpr(ISerializationContext context, ConstraintExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintsSpecification returns ConstraintsSpecification
	 *
	 * Constraint:
	 *     csts=ConstraintExpr
	 */
	protected void sequence_ConstraintsSpecification(ISerializationContext context, ConstraintsSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getConstraintsSpecification_Csts()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getConstraintsSpecification_Csts()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintsSpecificationAccess().getCstsConstraintExprParserRuleCall_1_0(), semanticObject.getCsts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Convert
	 *     FMLAbstractCommand returns Convert
	 *     StrCommand returns Convert
	 *     Convert returns Convert
	 *
	 * Constraint:
	 *     (v=FMCommand format=FMFormat)
	 */
	protected void sequence_Convert(ISerializationContext context, Convert semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getConvert_V()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getConvert_V()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getConvert_Format()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getConvert_Format()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConvertAccess().getVFMCommandParserRuleCall_1_0(), semanticObject.getV());
		feeder.accept(grammarAccess.getConvertAccess().getFormatFMFormatEnumRuleCall_3_0(), semanticObject.getFormat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CopyVariable
	 *     FMLAbstractCommand returns CopyVariable
	 *     FMCommand returns CopyVariable
	 *     FTCommand returns CopyVariable
	 *     StrCommand returns CopyVariable
	 *     VariabilityOpCommand returns CopyVariable
	 *     CopyVariable returns CopyVariable
	 *
	 * Constraint:
	 *     vid=FML_IDENTIFIER
	 */
	protected void sequence_CopyVariable(ISerializationContext context, CopyVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCopyVariable_Vid()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCopyVariable_Vid()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyVariableAccess().getVidFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVid());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Cores
	 *     FMLAbstractCommand returns Cores
	 *     SetCommand returns Cores
	 *     Cores returns Cores
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_Cores(ISerializationContext context, Cores semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCores_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCores_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoresAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CreateConfiguration
	 *     FMLAbstractCommand returns CreateConfiguration
	 *     ConfigurationCommand returns CreateConfiguration
	 *     ConfigurationCmd returns CreateConfiguration
	 *     CreateConfiguration returns CreateConfiguration
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_CreateConfiguration(ISerializationContext context, CreateConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getCreateConfiguration_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getCreateConfiguration_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateConfigurationAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Deads
	 *     FMLAbstractCommand returns Deads
	 *     SetCommand returns Deads
	 *     Deads returns Deads
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_Deads(ISerializationContext context, Deads semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getDeads_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getDeads_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeadsAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     var=FML_IDENTIFIER
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getDependency_Var()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getDependency_Var()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDependencyAccess().getVarFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DescendantFeature returns DescendantFeature
	 *
	 * Constraint:
	 *     val='descendants'
	 */
	protected void sequence_DescendantFeature(ISerializationContext context, DescendantFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getDescendantFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getDescendantFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDescendantFeatureAccess().getValDescendantsKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns DeselectedConfiguration
	 *     FMLAbstractCommand returns DeselectedConfiguration
	 *     SetCommand returns DeselectedConfiguration
	 *     ConfigurationCmd returns DeselectedConfiguration
	 *     DeselectedConfiguration returns DeselectedConfiguration
	 *
	 * Constraint:
	 *     config=ConfigurationCommand
	 */
	protected void sequence_DeselectedConfiguration(ISerializationContext context, DeselectedConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getDeselectedConfiguration_Config()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getDeselectedConfiguration_Config()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeselectedConfigurationAccess().getConfigConfigurationCommandParserRuleCall_1_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exist returns Exist
	 *
	 * Constraint:
	 *     (val='isExisting' var=FML_IDENTIFIER)
	 */
	protected void sequence_Exist(ISerializationContext context, Exist semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getExist_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getExist_Val()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getExist_Var()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getExist_Var()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistAccess().getValIsExistingKeyword_0_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getExistAccess().getVarFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exit returns Exit
	 *
	 * Constraint:
	 *     (val='quit' | val='exit')
	 */
	protected void sequence_Exit(ISerializationContext context, Exit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Export returns Export
	 *
	 * Constraint:
	 *     arg=LVidentifier
	 */
	protected void sequence_Export(ISerializationContext context, Export semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getExport_Arg()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getExport_Arg()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportAccess().getArgLVidentifierParserRuleCall_1_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Extract
	 *     FMLAbstractCommand returns Extract
	 *     FMCommand returns Extract
	 *     FeatureModelOperation returns Extract
	 *     Extract returns Extract
	 *
	 * Constraint:
	 *     rootfeature=FTCommand
	 */
	protected void sequence_Extract(ISerializationContext context, Extract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getExtract_Rootfeature()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getExtract_Rootfeature()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtractAccess().getRootfeatureFTCommandParserRuleCall_1_0(), semanticObject.getRootfeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FMLAbstractCommand returns FMFeature
	 *     FMCommand returns FMFeature
	 *     FMFeature returns FMFeature
	 *
	 * Constraint:
	 *     val='whichfm'
	 */
	protected void sequence_FMFeature(ISerializationContext context, FMFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFMFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFMFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFMFeatureAccess().getValWhichfmKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns FMLSave
	 *     FMLAbstractCommand returns FMLSave
	 *     FMLSave returns FMLSave
	 *
	 * Constraint:
	 *     (v=FMCommand format=FMFormat)
	 */
	protected void sequence_FMLSave(ISerializationContext context, FMLSave semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFMLSave_V()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFMLSave_V()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFMLSave_Format()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFMLSave_Format()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFMLSaveAccess().getVFMCommandParserRuleCall_1_0(), semanticObject.getV());
		feeder.accept(grammarAccess.getFMLSaveAccess().getFormatFMFormatEnumRuleCall_3_0(), semanticObject.getFormat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FamiliarScript returns FamiliarScript
	 *
	 * Constraint:
	 *     (
	 *         (((params+=Parameter+ cmds+=ScriptCommand+) | cmds+=ScriptCommand+)? (exports+=Export | exports+=Hidden)+) | 
	 *         (exports+=Export | exports+=Hidden)+
	 *     )?
	 */
	protected void sequence_FamiliarScript(ISerializationContext context, FamiliarScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureExpression returns FeatureExpression
	 *
	 * Constraint:
	 *     (ft=IdentifierExpr | ft=StringExpr)
	 */
	protected void sequence_FeatureExpression(ISerializationContext context, FeatureExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns FeatureModel
	 *     FMLAbstractCommand returns FeatureModel
	 *     FMCommand returns FeatureModel
	 *     FeatureModel returns FeatureModel
	 *
	 * Constraint:
	 *     (root=ID | (features+=Production+ expr+=CNF*) | file=StringExpr)
	 */
	protected void sequence_FeatureModel(ISerializationContext context, FeatureModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns FeatureOperation
	 *     FMLAbstractCommand returns FeatureOperation
	 *     FTCommand returns FeatureOperation
	 *     StrCommand returns FeatureOperation
	 *     SetCommand returns FeatureOperation
	 *     FeatureOperation returns FeatureOperation
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             op=AncestorFeature | 
	 *             op=DescendantFeature | 
	 *             op=ChildrenFeature | 
	 *             op=SiblingFeature | 
	 *             op=ParentFeature | 
	 *             op=NameFeature | 
	 *             op=FMFeature | 
	 *             op=FeatureOperator
	 *         ) 
	 *         feature=FTCommand
	 *     )
	 */
	protected void sequence_FeatureOperation(ISerializationContext context, FeatureOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureOperator returns FeatureOperator
	 *
	 * Constraint:
	 *     val='operator'
	 */
	protected void sequence_FeatureOperator(ISerializationContext context, FeatureOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFeatureOperator_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFeatureOperator_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureOperatorAccess().getValOperatorKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns FeatureVariabilityOperator
	 *     FeatureVariabilityOperator returns FeatureVariabilityOperator
	 *     FMLAbstractCommand returns FeatureVariabilityOperator
	 *     VariabilityOpCommand returns FeatureVariabilityOperator
	 *
	 * Constraint:
	 *     val=FeatureEdgeKind
	 */
	protected void sequence_FeatureVariabilityOperator(ISerializationContext context, FeatureVariabilityOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFeatureVariabilityOperator_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFeatureVariabilityOperator_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureVariabilityOperatorAccess().getValFeatureEdgeKindEnumRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ForeachSet
	 *     ForeachSet returns ForeachSet
	 *     FMLAbstractCommand returns ForeachSet
	 *
	 * Constraint:
	 *     (val=FML_IDENTIFIER var=FML_IDENTIFIER exprs+=ScriptCommand+)
	 */
	protected void sequence_ForeachSet(ISerializationContext context, ForeachSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns FullMandatorys
	 *     FMLAbstractCommand returns FullMandatorys
	 *     SetCommand returns FullMandatorys
	 *     FullMandatorys returns FullMandatorys
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_FullMandatorys(ISerializationContext context, FullMandatorys semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getFullMandatorys_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getFullMandatorys_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFullMandatorysAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns GDisplay
	 *     FMLAbstractCommand returns GDisplay
	 *     GDisplay returns GDisplay
	 *
	 * Constraint:
	 *     (cmdDisplay='gdisplay' (var=FMCommand | var=ConfigurationCommand))
	 */
	protected void sequence_GDisplay(ISerializationContext context, GDisplay semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns GListing
	 *     FMLAbstractCommand returns GListing
	 *     GListing returns GListing
	 *
	 * Constraint:
	 *     cmd='glisting'?
	 */
	protected void sequence_GListing(ISerializationContext context, GListing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns GetConstraints
	 *     FMLAbstractCommand returns GetConstraints
	 *     SetCommand returns GetConstraints
	 *     GetConstraints returns GetConstraints
	 *
	 * Constraint:
	 *     (kindOfGet=KindOfGet fm=FMCommand)
	 */
	protected void sequence_GetConstraints(ISerializationContext context, GetConstraints semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getGetConstraints_KindOfGet()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getGetConstraints_KindOfGet()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getGetConstraints_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getGetConstraints_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetConstraintsAccess().getKindOfGetKindOfGetEnumRuleCall_0_0(), semanticObject.getKindOfGet());
		feeder.accept(grammarAccess.getGetConstraintsAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns GetFGroups
	 *     FMLAbstractCommand returns GetFGroups
	 *     SetCommand returns GetFGroups
	 *     GetFGroups returns GetFGroups
	 *
	 * Constraint:
	 *     (kindOfGroups=KindOfGetGroups fm=FMCommand)
	 */
	protected void sequence_GetFGroups(ISerializationContext context, GetFGroups semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getGetFGroups_KindOfGroups()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getGetFGroups_KindOfGroups()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getGetFGroups_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getGetFGroups_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetFGroupsAccess().getKindOfGroupsKindOfGetGroupsEnumRuleCall_0_0(), semanticObject.getKindOfGroups());
		feeder.accept(grammarAccess.getGetFGroupsAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroupsSpecification returns GroupsSpecification
	 *
	 * Constraint:
	 *     groups+=GroupSpec+
	 */
	protected void sequence_GroupsSpecification(ISerializationContext context, GroupsSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HProduction returns HProduction
	 *
	 * Constraint:
	 *     (name=ID features+=FT_ID+)
	 */
	protected void sequence_HProduction(ISerializationContext context, HProduction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hidden returns Hidden
	 *
	 * Constraint:
	 *     arg=LVidentifier
	 */
	protected void sequence_Hidden(ISerializationContext context, Hidden semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getHidden_Arg()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getHidden_Arg()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHiddenAccess().getArgLVidentifierParserRuleCall_1_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HierarchySpecification returns HierarchySpecification
	 *
	 * Constraint:
	 *     (hierarchy=Hierarchy | features+=HProduction+)
	 */
	protected void sequence_HierarchySpecification(ISerializationContext context, HierarchySpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Hierarchy
	 *     FMLAbstractCommand returns Hierarchy
	 *     FMCommand returns Hierarchy
	 *     Hierarchy returns Hierarchy
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_Hierarchy(ISerializationContext context, Hierarchy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getHierarchy_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getHierarchy_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHierarchyAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IdentifierExpr
	 *     IdentifierExpr returns IdentifierExpr
	 *     FMLAbstractCommand returns IdentifierExpr
	 *     FMCommand returns IdentifierExpr
	 *     FTCommand returns IdentifierExpr
	 *     BCommand returns IdentifierExpr
	 *     StrCommand returns IdentifierExpr
	 *     ConfigurationCommand returns IdentifierExpr
	 *     SetCommand returns IdentifierExpr
	 *     ConstraintCommand returns IdentifierExpr
	 *     IntegerCommand returns IdentifierExpr
	 *     VariabilityOpCommand returns IdentifierExpr
	 *
	 * Constraint:
	 *     (val=FML_IDENTIFIER metaID=StringExpr?)
	 */
	protected void sequence_IdentifierExpr(ISerializationContext context, IdentifierExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IfCondition
	 *     IfCondition returns IfCondition
	 *     FMLAbstractCommand returns IfCondition
	 *
	 * Constraint:
	 *     (bexpr=ComplexCommand then+=ScriptCommand+ else+=ScriptCommand*)
	 */
	protected void sequence_IfCondition(ISerializationContext context, IfCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns Impl_expr
	 *     Or_expr returns Impl_expr
	 *     Or_expr.Or_expr_1_0 returns Impl_expr
	 *     And_expr returns Impl_expr
	 *     And_expr.And_expr_1_0 returns Impl_expr
	 *     Impl_expr returns Impl_expr
	 *     Impl_expr.Impl_expr_1_0 returns Impl_expr
	 *     Biimpl_expr returns Impl_expr
	 *     Biimpl_expr.Biimpl_expr_1_0 returns Impl_expr
	 *     Unary_expr returns Impl_expr
	 *     Primary_expr returns Impl_expr
	 *
	 * Constraint:
	 *     (left=Impl_expr_Impl_expr_1_0 right=Biimpl_expr)
	 */
	protected void sequence_Impl_expr(ISerializationContext context, Impl_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getImpl_expr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getImpl_expr_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getImpl_expr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getImpl_expr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpl_exprAccess().getImpl_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpl_exprAccess().getRightBiimpl_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Insert
	 *     FMLAbstractCommand returns Insert
	 *     BCommand returns Insert
	 *     FeatureModelOperation returns Insert
	 *     Insert returns Insert
	 *
	 * Constraint:
	 *     (aspectfm=FMCommand baseft=FTCommand op=VariabilityOpCommand)
	 */
	protected void sequence_Insert(ISerializationContext context, Insert semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getInsert_Aspectfm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getInsert_Aspectfm()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getInsert_Baseft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getInsert_Baseft()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getInsert_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getInsert_Op()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInsertAccess().getAspectfmFMCommandParserRuleCall_1_0(), semanticObject.getAspectfm());
		feeder.accept(grammarAccess.getInsertAccess().getBaseftFTCommandParserRuleCall_3_0(), semanticObject.getBaseft());
		feeder.accept(grammarAccess.getInsertAccess().getOpVariabilityOpCommandParserRuleCall_5_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IntLiteral
	 *     IntegerExpr returns IntLiteral
	 *     FMLAbstractCommand returns IntLiteral
	 *     IntegerCommand returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerExpr(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getIntLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getIntLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerExprAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BCommand returns IsConflicting
	 *     IsConflicting returns IsConflicting
	 *
	 * Constraint:
	 *     (val='isConflicting' var=FML_IDENTIFIER)
	 */
	protected void sequence_IsConflicting(ISerializationContext context, IsConflicting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getIsConflicting_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getIsConflicting_Val()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getIsConflicting_Var()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getIsConflicting_Var()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsConflictingAccess().getValIsConflictingKeyword_0_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getIsConflictingAccess().getVarFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IsEmptySet
	 *     FMLAbstractCommand returns IsEmptySet
	 *     BCommand returns IsEmptySet
	 *     SetOperations returns IsEmptySet
	 *     IsEmptySet returns IsEmptySet
	 *
	 * Constraint:
	 *     set=SetCommand
	 */
	protected void sequence_IsEmptySet(ISerializationContext context, IsEmptySet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getIsEmptySet_Set()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getIsEmptySet_Set()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsEmptySetAccess().getSetSetCommandParserRuleCall_1_0(), semanticObject.getSet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KnowledgeSpecification returns KnowledgeSpecification
	 *
	 * Constraint:
	 *     (hierarchy=HierarchySpecification? groups=GroupsSpecification? constraints=ConstraintsSpecification?)
	 */
	protected void sequence_KnowledgeSpecification(ISerializationContext context, KnowledgeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LArgs returns LArgs
	 *
	 * Constraint:
	 *     (args+=Command args+=Command*)
	 */
	protected void sequence_LArgs(ISerializationContext context, LArgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LFMArgs returns LFMArgs
	 *
	 * Constraint:
	 *     (lfms+=FMCommand lfms+=FMCommand*)
	 */
	protected void sequence_LFMArgs(ISerializationContext context, LFMArgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LVidentifier returns LVidentifier
	 *
	 * Constraint:
	 *     (args+=FML_IDENTIFIER args+=FML_IDENTIFIER*)
	 */
	protected void sequence_LVidentifier(ISerializationContext context, LVidentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Leaves
	 *     FMLAbstractCommand returns Leaves
	 *     SetCommand returns Leaves
	 *     Leaves returns Leaves
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_Leaves(ISerializationContext context, Leaves semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getLeaves_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getLeaves_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeavesAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Listing returns Listing
	 *
	 * Constraint:
	 *     ((val='ls' | val='vars') opt=OPT_LISTING?)
	 */
	protected void sequence_Listing(ISerializationContext context, Listing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns LoadGeneric
	 *     FMLAbstractCommand returns LoadGeneric
	 *     LoadGeneric returns LoadGeneric
	 *
	 * Constraint:
	 *     ((stream=STRING | stream=FML_IDENTIFIER) params+=FML_IDENTIFIER* ns=FML_IDENTIFIER?)
	 */
	protected void sequence_LoadGeneric(ISerializationContext context, LoadGeneric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns MandatoryEdit
	 *     FMLAbstractCommand returns MandatoryEdit
	 *     BCommand returns MandatoryEdit
	 *     ModifyVOperator returns MandatoryEdit
	 *     MandatoryEdit returns MandatoryEdit
	 *
	 * Constraint:
	 *     ft=FTCommand
	 */
	protected void sequence_MandatoryEdit(ISerializationContext context, MandatoryEdit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getMandatoryEdit_Ft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getMandatoryEdit_Ft()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMandatoryEditAccess().getFtFTCommandParserRuleCall_1_0(), semanticObject.getFt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Mandatory
	 *     Mandatory returns Mandatory
	 *
	 * Constraint:
	 *     name=FT_ID
	 */
	protected void sequence_Mandatory(ISerializationContext context, Mandatory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getMandatory_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getMandatory_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMandatoryAccess().getNameFT_IDParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Map
	 *     FMLAbstractCommand returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (fm=FMCommand cst=SetCommand)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getMap_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getMap_Fm()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getMap_Cst()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getMap_Cst()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.accept(grammarAccess.getMapAccess().getCstSetCommandParserRuleCall_3_0(), semanticObject.getCst());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Merge
	 *     FMLAbstractCommand returns Merge
	 *     FMCommand returns Merge
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (backend=BDDBackend? lazy?='--lazy'? mode=MergeMode (lfms+=FMCommand+ | fms=LFMArgs))
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupSpec returns MtxGroupSpec
	 *     MtxGroupSpec returns MtxGroupSpec
	 *
	 * Constraint:
	 *     (name=ID features+=FT_ID+)
	 */
	protected void sequence_MtxGroupSpec(ISerializationContext context, MtxGroupSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Mutexgroup
	 *     Mutexgroup returns Mutexgroup
	 *
	 * Constraint:
	 *     (features+=FT_ID features+=FT_ID+)
	 */
	protected void sequence_Mutexgroup(ISerializationContext context, Mutexgroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NameFeature returns NameFeature
	 *
	 * Constraint:
	 *     val='name'
	 */
	protected void sequence_NameFeature(ISerializationContext context, NameFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getNameFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getNameFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameFeatureAccess().getValNameKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns Neg_expr
	 *     Or_expr returns Neg_expr
	 *     Or_expr.Or_expr_1_0 returns Neg_expr
	 *     And_expr returns Neg_expr
	 *     And_expr.And_expr_1_0 returns Neg_expr
	 *     Impl_expr returns Neg_expr
	 *     Impl_expr.Impl_expr_1_0 returns Neg_expr
	 *     Biimpl_expr returns Neg_expr
	 *     Biimpl_expr.Biimpl_expr_1_0 returns Neg_expr
	 *     Unary_expr returns Neg_expr
	 *     Neg_expr returns Neg_expr
	 *     Primary_expr returns Neg_expr
	 *
	 * Constraint:
	 *     expr=Primary_expr
	 */
	protected void sequence_Neg_expr(ISerializationContext context, Neg_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getNeg_expr_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getNeg_expr_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNeg_exprAccess().getExprPrimary_exprParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns OptionalEdit
	 *     FMLAbstractCommand returns OptionalEdit
	 *     BCommand returns OptionalEdit
	 *     ModifyVOperator returns OptionalEdit
	 *     OptionalEdit returns OptionalEdit
	 *
	 * Constraint:
	 *     ft=FTCommand
	 */
	protected void sequence_OptionalEdit(ISerializationContext context, OptionalEdit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getOptionalEdit_Ft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getOptionalEdit_Ft()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionalEditAccess().getFtFTCommandParserRuleCall_1_0(), semanticObject.getFt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Optional
	 *     Optional returns Optional
	 *
	 * Constraint:
	 *     name=FT_ID
	 */
	protected void sequence_Optional(ISerializationContext context, Optional semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getOptional_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getOptional_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionalAccess().getNameFT_IDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns OrEdit
	 *     FMLAbstractCommand returns OrEdit
	 *     BCommand returns OrEdit
	 *     ModifyVOperator returns OrEdit
	 *     OrEdit returns OrEdit
	 *
	 * Constraint:
	 *     fts=SetCommand
	 */
	protected void sequence_OrEdit(ISerializationContext context, OrEdit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getOrEdit_Fts()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getOrEdit_Fts()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrEditAccess().getFtsSetCommandParserRuleCall_1_0(), semanticObject.getFts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroupSpec returns OrGroupSpec
	 *     OrGroupSpec returns OrGroupSpec
	 *
	 * Constraint:
	 *     (name=ID features+=FT_ID+)
	 */
	protected void sequence_OrGroupSpec(ISerializationContext context, OrGroupSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns Or_expr
	 *     Or_expr returns Or_expr
	 *     Or_expr.Or_expr_1_0 returns Or_expr
	 *     And_expr returns Or_expr
	 *     And_expr.And_expr_1_0 returns Or_expr
	 *     Impl_expr returns Or_expr
	 *     Impl_expr.Impl_expr_1_0 returns Or_expr
	 *     Biimpl_expr returns Or_expr
	 *     Biimpl_expr.Biimpl_expr_1_0 returns Or_expr
	 *     Unary_expr returns Or_expr
	 *     Primary_expr returns Or_expr
	 *
	 * Constraint:
	 *     (left=Or_expr_Or_expr_1_0 right=And_expr)
	 */
	protected void sequence_Or_expr(ISerializationContext context, Or_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getOr_expr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getOr_expr_Left()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getOr_expr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getOr_expr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOr_exprAccess().getOr_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOr_exprAccess().getRightAnd_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Orgroup
	 *     Orgroup returns Orgroup
	 *
	 * Constraint:
	 *     (features+=FT_ID features+=FT_ID+)
	 */
	protected void sequence_Orgroup(ISerializationContext context, Orgroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns PairwiseCommand
	 *     FMLAbstractCommand returns PairwiseCommand
	 *     SetCommand returns PairwiseCommand
	 *     PairwiseCommand returns PairwiseCommand
	 *
	 * Constraint:
	 *     (fm=FMCommand minimization=IntegerCommand? partial=IntegerCommand?)
	 */
	protected void sequence_PairwiseCommand(ISerializationContext context, PairwiseCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (param=FML_IDENTIFIER (typed=':' type=lType)?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.example.mydsl.fml.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParentFeature returns ParentFeature
	 *
	 * Constraint:
	 *     val='parent'
	 */
	protected void sequence_ParentFeature(ISerializationContext context, ParentFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getParentFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getParentFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParentFeatureAccess().getValParentKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CNF returns CNFExpression
	 *     Or_expr returns CNFExpression
	 *     Or_expr.Or_expr_1_0 returns CNFExpression
	 *     And_expr returns CNFExpression
	 *     And_expr.And_expr_1_0 returns CNFExpression
	 *     Impl_expr returns CNFExpression
	 *     Impl_expr.Impl_expr_1_0 returns CNFExpression
	 *     Biimpl_expr returns CNFExpression
	 *     Biimpl_expr.Biimpl_expr_1_0 returns CNFExpression
	 *     Unary_expr returns CNFExpression
	 *     Primary_expr returns CNFExpression
	 *
	 * Constraint:
	 *     (name=FT_ID | name='true' | name='false')
	 */
	protected void sequence_Primary_expr(ISerializationContext context, CNFExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns PrinterUtility
	 *     FMLAbstractCommand returns PrinterUtility
	 *     PrinterUtility returns PrinterUtility
	 *
	 * Constraint:
	 *     ((op='print' | op='println') arg=LArgs)
	 */
	protected void sequence_PrinterUtility(ISerializationContext context, PrinterUtility semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Production returns Production
	 *
	 * Constraint:
	 *     (name=FT_ID features+=Child+)
	 */
	protected void sequence_Production(ISerializationContext context, Production semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns RemoveConstraint
	 *     FMLAbstractCommand returns RemoveConstraint
	 *     RemoveConstraint returns RemoveConstraint
	 *
	 * Constraint:
	 *     (cst=ConstraintCommand fm=FMCommand)
	 */
	protected void sequence_RemoveConstraint(ISerializationContext context, RemoveConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRemoveConstraint_Cst()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRemoveConstraint_Cst()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRemoveConstraint_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRemoveConstraint_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveConstraintAccess().getCstConstraintCommandParserRuleCall_1_0(), semanticObject.getCst());
		feeder.accept(grammarAccess.getRemoveConstraintAccess().getFmFMCommandParserRuleCall_3_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns RemoveFeature
	 *     FMLAbstractCommand returns RemoveFeature
	 *     BCommand returns RemoveFeature
	 *     FeatureModelOperation returns RemoveFeature
	 *     EditOperation returns RemoveFeature
	 *     RemoveFeature returns RemoveFeature
	 *
	 * Constraint:
	 *     feature=FTCommand
	 */
	protected void sequence_RemoveFeature(ISerializationContext context, RemoveFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRemoveFeature_Feature()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRemoveFeature_Feature()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveFeatureAccess().getFeatureFTCommandParserRuleCall_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns RemoveVariable
	 *     FMLAbstractCommand returns RemoveVariable
	 *     BCommand returns RemoveVariable
	 *     RemoveVariable returns RemoveVariable
	 *
	 * Constraint:
	 *     vid=FML_IDENTIFIER
	 */
	protected void sequence_RemoveVariable(ISerializationContext context, RemoveVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRemoveVariable_Vid()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRemoveVariable_Vid()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveVariableAccess().getVidFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVid());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns RenameFeature
	 *     FMLAbstractCommand returns RenameFeature
	 *     BCommand returns RenameFeature
	 *     FeatureModelOperation returns RenameFeature
	 *     EditOperation returns RenameFeature
	 *     RenameFeature returns RenameFeature
	 *
	 * Constraint:
	 *     (feature=FTCommand featureNew=StrCommand)
	 */
	protected void sequence_RenameFeature(ISerializationContext context, RenameFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRenameFeature_Feature()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRenameFeature_Feature()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getRenameFeature_FeatureNew()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getRenameFeature_FeatureNew()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRenameFeatureAccess().getFeatureFTCommandParserRuleCall_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getRenameFeatureAccess().getFeatureNewStrCommandParserRuleCall_3_0(), semanticObject.getFeatureNew());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptCommand returns ScriptCommand
	 *
	 * Constraint:
	 *     (var=FML_IDENTIFIER metaID=StringExpr? cmd=ComplexCommand)
	 */
	protected void sequence_ScriptCommand(ISerializationContext context, ScriptCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ScriptDefinition
	 *     FMLAbstractCommand returns ScriptDefinition
	 *     ScriptDefinition returns ScriptDefinition
	 *
	 * Constraint:
	 *     (params+=Parameter* cmds+=ScriptCommand+ (exports+=Export | exports+=Hidden)*)
	 */
	protected void sequence_ScriptDefinition(ISerializationContext context, ScriptDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SelectedConfiguration
	 *     FMLAbstractCommand returns SelectedConfiguration
	 *     SetCommand returns SelectedConfiguration
	 *     ConfigurationCmd returns SelectedConfiguration
	 *     SelectedConfiguration returns SelectedConfiguration
	 *
	 * Constraint:
	 *     config=ConfigurationCommand
	 */
	protected void sequence_SelectedConfiguration(ISerializationContext context, SelectedConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSelectedConfiguration_Config()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSelectedConfiguration_Config()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectedConfigurationAccess().getConfigConfigurationCommandParserRuleCall_1_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SelectionFeature
	 *     FMLAbstractCommand returns SelectionFeature
	 *     ConfigurationCmd returns SelectionFeature
	 *     SelectionFeature returns SelectionFeature
	 *
	 * Constraint:
	 *     ((op='select' | op='deselect' | op='unselect') fts+=FeatureExpression+ config=ConfigurationCommand)
	 */
	protected void sequence_SelectionFeature(ISerializationContext context, SelectionFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetAddOrRemove
	 *     FMLAbstractCommand returns SetAddOrRemove
	 *     SetOperations returns SetAddOrRemove
	 *     SetAddOrRemove returns SetAddOrRemove
	 *
	 * Constraint:
	 *     ((op='setAdd' | op='setRemove') setl=SetCommand var=Command)
	 */
	protected void sequence_SetAddOrRemove(ISerializationContext context, SetAddOrRemove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetBelongs
	 *     FMLAbstractCommand returns SetBelongs
	 *     BCommand returns SetBelongs
	 *     SetOperations returns SetBelongs
	 *     SetBelongs returns SetBelongs
	 *
	 * Constraint:
	 *     (setl=FML_IDENTIFIER setr=FML_IDENTIFIER)
	 */
	protected void sequence_SetBelongs(ISerializationContext context, SetBelongs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetBelongs_Setl()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetBelongs_Setl()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetBelongs_Setr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetBelongs_Setr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetBelongsAccess().getSetlFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getSetl());
		feeder.accept(grammarAccess.getSetBelongsAccess().getSetrFML_IDENTIFIERParserRuleCall_2_0(), semanticObject.getSetr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetCard
	 *     FMLAbstractCommand returns SetCard
	 *     IntegerCommand returns SetCard
	 *     SetOperations returns SetCard
	 *     SetCard returns SetCard
	 *
	 * Constraint:
	 *     set=SetCommand
	 */
	protected void sequence_SetCard(ISerializationContext context, SetCard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetCard_Set()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetCard_Set()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetCardAccess().getSetSetCommandParserRuleCall_1_0(), semanticObject.getSet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetEmpty
	 *     FMLAbstractCommand returns SetEmpty
	 *     SetCommand returns SetEmpty
	 *     SetOperations returns SetEmpty
	 *     SetEmpty returns SetEmpty
	 *
	 * Constraint:
	 *     val='setEmpty'
	 */
	protected void sequence_SetEmpty(ISerializationContext context, SetEmpty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetEmpty_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetEmpty_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetEmptyAccess().getValSetEmptyKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetExpr
	 *     SetExpr returns SetExpr
	 *     FMLAbstractCommand returns SetExpr
	 *     SetCommand returns SetExpr
	 *
	 * Constraint:
	 *     e+=ComplexCommand+
	 */
	protected void sequence_SetExpr(ISerializationContext context, SetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetToNames
	 *     FMLAbstractCommand returns SetToNames
	 *     SetCommand returns SetToNames
	 *     SetOperations returns SetToNames
	 *     SetToNames returns SetToNames
	 *
	 * Constraint:
	 *     set=SetCommand
	 */
	protected void sequence_SetToNames(ISerializationContext context, SetToNames semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSetToNames_Set()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSetToNames_Set()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetToNamesAccess().getSetSetCommandParserRuleCall_1_0(), semanticObject.getSet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetUnionOrIntersection
	 *     FMLAbstractCommand returns SetUnionOrIntersection
	 *     SetCommand returns SetUnionOrIntersection
	 *     SetOperations returns SetUnionOrIntersection
	 *     SetUnionOrIntersection returns SetUnionOrIntersection
	 *
	 * Constraint:
	 *     ((op='setUnion' | op='setIntersection' | op='setDiff') setl=SetCommand setr=SetCommand)
	 */
	protected void sequence_SetUnionOrIntersection(ISerializationContext context, SetUnionOrIntersection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Shell
	 *     FMLAbstractCommand returns Shell
	 *     Shell returns Shell
	 *
	 * Constraint:
	 *     (cmd=Exit | cmd=Exist | cmd=Listing | cmd=IsConflicting | cmd=State)
	 */
	protected void sequence_Shell(ISerializationContext context, Shell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SiblingFeature returns SiblingFeature
	 *
	 * Constraint:
	 *     val='sibling'
	 */
	protected void sequence_SiblingFeature(ISerializationContext context, SiblingFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSiblingFeature_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSiblingFeature_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSiblingFeatureAccess().getValSiblingKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Slice
	 *     FMLAbstractCommand returns Slice
	 *     FMCommand returns Slice
	 *     Slice returns Slice
	 *
	 * Constraint:
	 *     (fm=FMCommand mode=SliceMode fts=SetCommand)
	 */
	protected void sequence_Slice(ISerializationContext context, Slice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSlice_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSlice_Fm()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSlice_Mode()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSlice_Mode()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getSlice_Fts()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getSlice_Fts()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSliceAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.accept(grammarAccess.getSliceAccess().getModeSliceModeEnumRuleCall_2_0(), semanticObject.getMode());
		feeder.accept(grammarAccess.getSliceAccess().getFtsSetCommandParserRuleCall_3_0(), semanticObject.getFts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (val='memory' | val='cpu')
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringConcat
	 *     FMLAbstractCommand returns StringConcat
	 *     StrCommand returns StringConcat
	 *     StringOperation returns StringConcat
	 *     StringConcat returns StringConcat
	 *
	 * Constraint:
	 *     (lstr=StrCommand rstr=StrCommand)
	 */
	protected void sequence_StringConcat(ISerializationContext context, StringConcat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringConcat_Lstr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringConcat_Lstr()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringConcat_Rstr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringConcat_Rstr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConcatAccess().getLstrStrCommandParserRuleCall_1_0(), semanticObject.getLstr());
		feeder.accept(grammarAccess.getStringConcatAccess().getRstrStrCommandParserRuleCall_2_0(), semanticObject.getRstr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringExpr
	 *     StringExpr returns StringExpr
	 *     FMLAbstractCommand returns StringExpr
	 *     StrCommand returns StringExpr
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_StringExpr(ISerializationContext context, StringExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringExpr_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringExpr_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExprAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringIndexOf
	 *     FMLAbstractCommand returns StringIndexOf
	 *     IntegerCommand returns StringIndexOf
	 *     StringOperation returns StringIndexOf
	 *     StringIndexOf returns StringIndexOf
	 *
	 * Constraint:
	 *     (str=StrCommand schar=StrCommand)
	 */
	protected void sequence_StringIndexOf(ISerializationContext context, StringIndexOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringIndexOf_Str()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringIndexOf_Str()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringIndexOf_Schar()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringIndexOf_Schar()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringIndexOfAccess().getStrStrCommandParserRuleCall_1_0(), semanticObject.getStr());
		feeder.accept(grammarAccess.getStringIndexOfAccess().getScharStrCommandParserRuleCall_2_0(), semanticObject.getSchar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringInit
	 *     FMLAbstractCommand returns StringInit
	 *     StrCommand returns StringInit
	 *     StringOperation returns StringInit
	 *     StringInit returns StringInit
	 *
	 * Constraint:
	 *     val='strInit'
	 */
	protected void sequence_StringInit(ISerializationContext context, StringInit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringInit_Val()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringInit_Val()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringInitAccess().getValStrInitKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringLength
	 *     FMLAbstractCommand returns StringLength
	 *     IntegerCommand returns StringLength
	 *     StringOperation returns StringLength
	 *     StringLength returns StringLength
	 *
	 * Constraint:
	 *     str=StrCommand
	 */
	protected void sequence_StringLength(ISerializationContext context, StringLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringLength_Str()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringLength_Str()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLengthAccess().getStrStrCommandParserRuleCall_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StringSubstring
	 *     FMLAbstractCommand returns StringSubstring
	 *     StrCommand returns StringSubstring
	 *     StringOperation returns StringSubstring
	 *     StringSubstring returns StringSubstring
	 *
	 * Constraint:
	 *     (str=StrCommand begin=IntegerCommand end=IntegerCommand)
	 */
	protected void sequence_StringSubstring(ISerializationContext context, StringSubstring semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_Str()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_Str()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_Begin()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_Begin()));
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_End()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getStringSubstring_End()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringSubstringAccess().getStrStrCommandParserRuleCall_1_0(), semanticObject.getStr());
		feeder.accept(grammarAccess.getStringSubstringAccess().getBeginIntegerCommandParserRuleCall_2_0(), semanticObject.getBegin());
		feeder.accept(grammarAccess.getStringSubstringAccess().getEndIntegerCommandParserRuleCall_3_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Synthesis
	 *     FMLAbstractCommand returns Synthesis
	 *     FMCommand returns Synthesis
	 *     Synthesis returns Synthesis
	 *
	 * Constraint:
	 *     (interactive?='--interactive'? fm=FMCommand (over?='over' fts=SetCommand)? kst=KnowledgeSpecification?)
	 */
	protected void sequence_Synthesis(ISerializationContext context, Synthesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns UnMap
	 *     FMLAbstractCommand returns UnMap
	 *     UnMap returns UnMap
	 *
	 * Constraint:
	 *     fm=FMCommand
	 */
	protected void sequence_UnMap(ISerializationContext context, UnMap semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getUnMap_Fm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getUnMap_Fm()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnMapAccess().getFmFMCommandParserRuleCall_1_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns UnselectedConfiguration
	 *     FMLAbstractCommand returns UnselectedConfiguration
	 *     ConfigurationCmd returns UnselectedConfiguration
	 *     UnselectedConfiguration returns UnselectedConfiguration
	 *
	 * Constraint:
	 *     config=ConfigurationCommand
	 */
	protected void sequence_UnselectedConfiguration(ISerializationContext context, UnselectedConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getUnselectedConfiguration_Config()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getUnselectedConfiguration_Config()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnselectedConfigurationAccess().getConfigConfigurationCommandParserRuleCall_1_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns VariableNull
	 *     FMLAbstractCommand returns VariableNull
	 *     VariableNull returns VariableNull
	 *
	 * Constraint:
	 *     var=FML_IDENTIFIER
	 */
	protected void sequence_VariableNull(ISerializationContext context, VariableNull semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FmlPackage.eINSTANCE.getVariableNull_Var()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FmlPackage.eINSTANCE.getVariableNull_Var()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableNullAccess().getVarFML_IDENTIFIERParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroupSpec returns XorGroupSpec
	 *     XorGroupSpec returns XorGroupSpec
	 *
	 * Constraint:
	 *     (name=ID features+=FT_ID+)
	 */
	protected void sequence_XorGroupSpec(ISerializationContext context, XorGroupSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Xorgroup
	 *     Xorgroup returns Xorgroup
	 *
	 * Constraint:
	 *     (features+=FT_ID features+=FT_ID+)
	 */
	protected void sequence_Xorgroup(ISerializationContext context, Xorgroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     lType returns lType
	 *
	 * Constraint:
	 *     (
	 *         val='FeatureModel' | 
	 *         val='Feature' | 
	 *         val='Boolean' | 
	 *         val='String' | 
	 *         val='Configuration' | 
	 *         val='Set' | 
	 *         val='Double' | 
	 *         val='Integer' | 
	 *         val='Constraint'
	 *     )
	 */
	protected void sequence_lType(ISerializationContext context, lType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
