/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * This is a description of the XYZ feature diagram file format. *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * The format is illustrated with a PC product line.
 *
 */

/*
 * As you have noticed, comments are written in a  C-style syntax.  They can be placed anywhere and are filtered out by the
 * preprocessor before the compilation.
 */



/* 
 * Before specifying the feature diagram, the user may want to define some attribute types. Each type has a value domain and is 
 * terminated with a ";". The basic attribute types are  "bool", "enum", "int" and "real".
 * 
 * Naming convention feature names start with a capital letter. All other names (attributes, types,...) start with a lowercase letter.
 */

/*
 * An enum is  list of possible values.  Each value has to be unique for the enum (but not globally).  There is no restriction as 
 * to the names that can be used.  "enum width { 1, 2, 3, 4, 5 }" is a valid enum.  Operations on enum are "in", ==, !=, <=, >=, <, > 
 * where the order is the order in which the values were declared (i.e. LGA1156 > ASB1).
 */
enum cpuSocket {
	lGA1156, 
	aSB1
};

/**
*
*
*/
enum screenConnectivity {
	vGA, 
	dVI
};

/*
 * In addition to the basic types, a type may be a hierarchical structure ("struct") that has several fields. 
 */ 
struct motherBoardSize { 
	int height;  
	int width;
}

/*
 * After the types statement, the user may specify some constants thanks to the keyword "define". 
 */ 
const int maxRamBlocks 4;

/* 
 * After the type declarations comes the feature diagram itself.  It starts with the root feature, which must be 
 * preceded by the keyword "root". A feature block consists of the following 
 *  - The feature constraints
 *  - The feature attributes
 *  - The children of the feature There are two ways to specify the children of a feature
 *      1) The "hierarchical" way Fully specify the child feature in this place (the complete feature block)
 *    	2) The "grammatical" way  Only specify the ID (and optional state) of the child feature (without its block). 
 *    	   The details of the child feature (its block) is provided later in the file. 
 * 
 * More generally, the definition of a feature can be spread over an arbitrary number of feature blocks.  This is 
 * semantically equivalent to specifying a single definition with the lines that are otherwise spread.  The compiler 
 * will simply join the contents of each of the blocks.  The children block of a feature can only be specified in one 
 * piece, though (it cannot be spread over different blocks).
 * 
 * 
 * In our example, the children of the feature "computer" are specified in the grammatical way.  The group statement 
 * contains only the ID of the child features and the user has chosen to specify the attributes and the constraints later.
 *
 * The cardinality of the group statement ("[x..y]") shows the minimum ("x") and maximum ("y") number of children 
 * features.  One can use the wildcard char * to indicate the maximum number of features.
 * 
 * Instead of using cardinalities, one can also use the standard decomposition operators "oneof", "allof", "noneof".
 */
root Computer { // <- The braces that delimit the feature block can be omitted
	group [3..*] {  // <- The braces of the children block are mandatory
		Motherboard,
		CPU, 
		Graphic_Card,
		// A feature preceded by the keyword "opt" indicates that the feature "Accessories" is optional. 
		opt Accessories
	}	
} // This is the end of the definition of the computer feature.


/*
 * Since this block is also called "Computer", it designates the same feature as before, the declarations in here will 
 * be added to the previous ones.
 */
Computer {
	data{
		"key"   "value";
		"key2"  "someothervalue"
	} 
	/*
	 * When a user creates a new attribute, he must specify 
	 * 1) The attribute type  Basic type ("bool", "int", "real" and "enum") or a self created type.
	 * 2) The attribute name.
	 * 3) The domain of the attribute "in { enumaritive list, .. }" "in [interval]" (optionnal)
	 * 4) The value the attribute takes when its parent feature is selected "ifin ..." (optionnal)
	 * 5) The value the attribute takes when its parent feature is deselected "ifout ..." (optional)
	 *
	 * The value is simply an expression with the type of the attribute.  The syntax for these expressions
	 * is as expected (operators + - * / for numeric expressions and && || ==> <=> ! for boolean expressions.
	 * In addition, there are a number of aggregation operators, such as sum, max, min, mult, count, 
	 * avg for numeric attributes as well as and, or, xor for boolean attributes.
	 * 
	 * Inside these aggregation operators, one can also make use of special keywords to range over the 
	 * child features of the feature the attribute belongs to
	 *	 - "children.ATTRIBUTE" denotes the value of ATTRIBUTE of all the child features
	 *   - "selectedChildren.ATTRIBUTE" denotes the the value of ATTRIBUTE of the selected child features only
	 * The attribute ATTRIBUTE has to declared for all the child features, all with the same type, and the type
	 * has to match the aggregation function.
	 *
	 * An attribute may be referenced in two ways 
	 *  1) FEATURE.ATTRIBUTE, where FEATURE is the name of the parent feature and ATTRIBUTE the name of the attribute
	 *  2) FEATURE1.FEATURE2.ATTRIBUTE, where FEATURE1.FEATURE2 is a path in the diagram.
	 *  3) Using a number of keywords
	 *      - this.ATTRIBUTE denotes an attribute of the current feature
	 *      - parent.ATTRIBUTE denotes an attribute of the parent of the current feature. This cannot be used
	 *        if the feature has more then one parent.
	 *
	 * In case of a struct, the fields of the struct can be referenced with dots as well FEATURE.ATTRIBUTE.SUBATTRIBUTE.
     */
	int price in [1..100], ifin: is sum(selectedchildren.price), ifout: is 0;
	
	/*
	 * A constraint is simply a boolean expression.  It can be preceded by one of the two key words 
	 *  - "ifin"  The constraint only has to hold when its feature is selected.
	 *  - "ifout"  The constraint only has to hold when its feature is deselected.
	 * 
	 * The two common constraints "requires" and "excludes" are built into the language (basically, they are boolean 
	 * operators).
	 * 
	 */
	ifin: Motherboard.socket == CPU.socket;
	
	/*
	 * The "include" statement is a preprocessor directive that allows to insert content of another file.
	 * into this file.  It works like a macro and has no additional semantics.
	 */
ifin: Motherboard.socket ==  aSB1;
	
	/*
	 * Each feature can contain a block with additional data.  This block is simply a list of couples (key, value).
	 * Their purpose is to make the format easily extensible; they are supposed to hold additional information about
	 * the feature that is not of interest to the analysis, but to some kind of tool (e.g. it could be a reference
	 * to a PDF file with documentation, it could be an indication of where in the code the feature is, it could even 
	 * be a string in XML format or a serialised object).
	 * 
	 * The key has to follow the same naming convention as other identifiers, except that it cannot be refereced
	 * anywhere in the doc (its only there for storage).  The Value is delimited by double quotes and a semicolon.
	 * Any double quotes inside the value should be escaped with a backslash.
	 *
	 * Data blocks are additive if there are many of them (all keys in the data blocks of a feature have to be unique).
	 */
}


Motherboard {
	int price, ifin: is sum(selectedchildren.price); 
	cpuSocket socket;
	/*
	 * In the case where the attribute is composed of sub-attributes (struct), each sub-attribute must be specified.
	 */
	motherBoardSize size {
		height, ifin: is sum(selectedchildren.size.height);
	    width, ifin: is sum(selectedchildren.size.width);
	}
	
	group oneof {
	 	Asus {
	    	int price, ifin: is 259;
	       	motherBoardSize size { 
	       		height, ifin: is 30;
	      		width, ifin: is 40;
	      	}
	
			/*
			 * The value of an enum is referenced directly.
			 */
	      	ifin: parent.socket == lGA1156 ; 
	    },
	    Aopen {
	       	int price, ifin: is 199;
	       	motherBoardSize size { 
	       		height, ifin: is 30;
	      		width, ifin: is 40;
	      	}	
	       	ifin: parent.socket == aSB1; 
	    }
	}
} 



CPU {	
	int price, ifin: is sum(selectedchildren.price);
	cpuSocket socket;
	group oneof { 
	    CoreI7 {
	      	int price, ifin: is 399;
	      	ifin: socket == lGA1156; 
	    	},
      	AthlonNeo {
	      	int price, ifin: is 299;	
	      	ifin: parent.socket == aSB1; 
	    },
		NVIDIA {
			int price;
			real test;
		}
	}
} 

root.Graphic_Card {
	int price, ifin: is sum(selectedchildren.price);
	screenConnectivity connectivity;
	enum test in { last, polo }, ifin: is last, ifout: is polo;
	int blbla in [123..128], ifin: in {123, 124, parent.price};
	group oneof {
		/*
		 * The keyword "shared" shows that PhilipsScreen is also a children feature of GraphicCard.
		 * This allows to declare a DAG instead of just a Tree.
		 */
		shared PhilipsScreen,
		shared SamsungScreen,
	    NVIDIA {
	      	int price, ifin: is 199;		
	      	ifin: parent.connectivity == dVI;
	    },
      	ATI {
	      	int price, ifin: is 159;		
	      	ifin: parent.connectivity == vGA; 
	    }
	}
}


Accessories {
	int price, ifin: is sum(selectedchildren.price);
	ifin: PhilipsScreen excludes SamsungScreen;
	group [1..2] { 
		opt LogitechKeyboardAndMouse {
			int price, ifin: is 19;
		},
		opt PhilipsScreen {
			int price, ifin: is 99;	  	  
			ifin: Graphic_Card.connectivity == vGA;
			
		},
		opt SamsungScreen {
			int price, ifin: is 149;	  
			ifin: Graphic_Card.connectivity == dVI;
		}
	}
}
