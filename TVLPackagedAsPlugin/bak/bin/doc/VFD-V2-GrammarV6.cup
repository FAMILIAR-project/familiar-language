// FEATUREMX VFD STAR FORMAT CUP PARSER SPECIFICATION


//PREPROCESS
//----------
package be.ac.fundp.info.TVLParser.Parser;

import be.ac.fundp.info.TVLParser.Parser.FeaturesStack;
import be.ac.fundp.info.TVLParser.syntaxTree.*;
import be.ac.fundp.info.TVLParser.symbolTables.FeaturesSymbolTable;
// Reacting to errors
parser code {:

	private String rootFeatureID;
	
	public void setRootFeatureID(String rootFeatureID) {
		this.rootFeatureID = rootFeatureID;	
	}
	
	public String getRootFeatureID() {
		return this.rootFeatureID;
	}
	 
	public void report_fatal_error ( String message, Object info ) throws Exception { 
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				 message = message + " in line "+(s.left+1);
				 if (s.right >= 0)
				 	message = message + ", column "+(s.right+1);
			}
		}
		throw new Exception("VFDStar schema parsing - Syntax Error - "+message); 
	} 
:}; 

// TERMINALS
// ---------

// Numbers
terminal ZERO;
terminal String INTEGER, REAL, STRING;

// Properties
terminal SHARED, ROOT, OPT, BOOL, INT, ENUM, STRUCT, REALP, IFIN, IFOUT, CONST;

// Cardinality
terminal GROUP, ONEOF, SOMEOF, ALLOF;

// Selectors
terminal PARENT, THIS, CHILDREN, SCHILDREN;

// Operators
terminal AND, OR, INVERSEIMPLIES, IMPLIES, IFANDONLYIF, NOT, TRUE, FALSE, NOTEQUALS, EQUALS,GREATER, LOWER, GEQ, LEQ, PLUS, MINUS, UMINUS, TIMES, DIVIDE, MAX, MIN, SUM, MUL, AVG, COUNT, ANDAGG, ORAGG, XORAGG, ABS, IN, EXCLUDES, REQUIRES;

// Other symbols
terminal SQBRA, SQBRAEND, COMMA, BRA, BRAEND, CBRA, CBRAEND, DOT, QUEST, COLON, SEMICOLON, DATA, QUOT;

// Identifier
terminal String ATTRIBUTE_ID, FEATURE_ID;

// NON TERMINALS
// -------------

non terminal Field field;

// Meta section


// Constant section
non terminal Constants constants;
non terminal Constant constant;

// Type section
non terminal Types types;
non terminal Type type;
non terminal BaseSet base_set;
non terminal Record record;
non terminal RecordContent record_content;
non terminal RecordField record_field;

// ID section
non terminal FeatureIDPath feature_id_path;
non terminal String feature_id_chain;
non terminal AttributeIDPath attribute_id_path;
non terminal String attribute_id_chain;
non terminal ChildrenAttributeID children_attribute_id;
non terminal FeatureIDList feature_id_list;
non terminal String parent_chain;

// Feature sections
non terminal Feature fd;
non terminal FeaturesGroup featuresGroup;
non terminal Feature feature;
non terminal HierarchicalFeatures hierarchical_features;
non terminal HierarchicalFeature hierarchical_feature;
non terminal Cardinality cardinality;

// Attribute section
non terminal Attributes attributes;
non terminal Attribute attribute;
non terminal BaseAttribute base_attribute;
non terminal IfInIfOut ifin_ifout;
non terminal StructAttributeContent struct_attribute_content;
non terminal SubAttribute sub_attribute;

// Expression section
non terminal Expression expression;
non terminal ExpressionList expression_list;
non terminal SetExpression set_expression;

// Constraint section
non terminal Constraints constraints;
non terminal Constraint constraint;

// Data section
non terminal Data data;
non terminal DataPairList data_pair_list;
non terminal DataPair data_pair;
non terminal Comment comment;

// PRECEDENCE AND ASSOCIATIVITY
// ----------------------------
//precedence left EQUALS;
//precedence right DOT;
//precedence left IMPLIES,IFANDONLYIF;
//precedence left OR,PLUS,MINUS; 
//precedence left AND,TIMES,DIVIDE;

precedence left COMMA;
precedence right QUEST;
precedence right INVERSEIMPLIES;
precedence left IMPLIES;
precedence nonassoc IFANDONLYIF;
precedence left OR;
precedence left AND;
precedence nonassoc EQUALS, NOTEQUALS, IN;
precedence nonassoc GEQ, LOWER, GREATER, LEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence nonassoc REQUIRES, EXCLUDES;
precedence right NOT, UMINUS, ABS, MIN, MAX, COUNT, AVG, XORAGG, MUL, SUM, ANDAGG, ORAGG;
precedence left DOT;

// THE GRAMMAR
// -----------

start with field;

field ::=  types:e1  constants:e2 fd:e3 {: RESULT = new Field(e1,e2,e3); :}
         ;

//----- Type section ------------------------------------------------------------------------------------------

types ::=  {: RESULT = null; :}
		 | type:e1 types:e2 {: RESULT = new Types(e1, e2); :}
		 ;
		 
type ::=  base_set:e1 {: RESULT = new Type(e1); :}
		| record:e1 {: RESULT = new Type(e1); :}
		;
		
base_set ::=  INT ATTRIBUTE_ID:e1 set_expression:e2 SEMICOLON {: RESULT = new BaseSet("int", e1, e2); :}
			| REALP ATTRIBUTE_ID:e1 set_expression:e2 SEMICOLON {: RESULT = new BaseSet("real", e1, e2); :}
			| ENUM ATTRIBUTE_ID:e1 set_expression:e2 SEMICOLON {: RESULT = new BaseSet("enum", e1, e2); :}
			;

			 
record ::=  STRUCT ATTRIBUTE_ID:e1 CBRA record_content:e2 CBRAEND SEMICOLON {: RESULT = new Record(e1, e2); :}
		  ;
		  
record_content ::=  record_field:e1 {: RESULT = new RecordContent(e1); :}
				  | record_field:e1 record_content:e2 {: RESULT = new RecordContent(e1, e2); :}
				  ;
				  
record_field ::=  base_set:e1 {: RESULT = new RecordField(e1); :}
			    | INT ATTRIBUTE_ID:e1 SEMICOLON {: RESULT = new RecordField("int", e1); :}
				| REALP ATTRIBUTE_ID:e1 SEMICOLON {: RESULT = new RecordField("real", e1); :}
				| BOOL ATTRIBUTE_ID:e1  SEMICOLON {: RESULT = new RecordField("bool", e1); :}
			    | ATTRIBUTE_ID:e1 ATTRIBUTE_ID:e2 SEMICOLON {: RESULT = new RecordField(e1, e2); :}
			    ;  
 
//----- Constant section ------------------------------------------------------------------------------------------

constants ::=  {: RESULT = null; :}
			 | constant:e1 constants:e2 {: RESULT = new Constants(e1, e2); :}
			 ;

constant ::=  CONST INT ATTRIBUTE_ID:e1 INTEGER:e2 SEMICOLON {: RESULT = new Constant("int", e1, e2); :}
			| CONST INT ATTRIBUTE_ID:e1 ZERO SEMICOLON {: RESULT = new Constant("int", e1, "0"); :}
			| CONST REALP ATTRIBUTE_ID:e1 REAL:e2 SEMICOLON {: RESULT = new Constant("real", e1, e2); :}
			| CONST REALP ATTRIBUTE_ID:e1 ZERO SEMICOLON {: RESULT = new Constant("real", e1,"0"); :}
			| CONST BOOL ATTRIBUTE_ID:e1 TRUE SEMICOLON  {: RESULT = new Constant("bool", e1, "true"); :}
			| CONST BOOL ATTRIBUTE_ID:e1 FALSE SEMICOLON {: RESULT = new Constant("bool", e1,"false"); :}
			; 

//----- ID section ------------------------------------------------------------------------------------------

feature_id_path ::=  ROOT DOT feature_id_chain:e1 {: RESULT = new FeatureIDPath(parser.getRootFeatureID()+"."+e1); :} 
				   | FEATURE_ID:e1 DOT feature_id_chain:e2 {: RESULT = new FeatureIDPath(e1+"."+e2); :}
				   | FEATURE_ID:e1 {: RESULT = new FeatureIDPath(e1); :} //Pour les en-têtes des features, pas zoli...
				   | THIS {: RESULT = new FeatureIDPath("this"); :}
				   ;
				   
feature_id_chain ::=  {: RESULT = ""; :}
					| FEATURE_ID:e1 {: RESULT = e1; :} //Pour les en-têtes des features, pas zoli...
					| FEATURE_ID:e1 DOT feature_id_chain:e2 {: RESULT = e1+"."+e2; :}
					;
					
attribute_id_path ::=  PARENT DOT parent_chain:e1 attribute_id_chain:e2 {: RESULT = new AttributeIDPath("parent.", e1, e2); :}
					 | THIS DOT attribute_id_chain:e1 {: RESULT = new AttributeIDPath("this.", e1); :}
					 | feature_id_path:e1 attribute_id_chain:e2 {: RESULT = new AttributeIDPath(e1, e2); :}
					 | attribute_id_chain:e1 {: RESULT = new AttributeIDPath(e1); :}
					 ;	 

parent_chain ::=  {: RESULT = ""; :}
				| PARENT DOT parent_chain:e1  {: RESULT = "parent."+e1; :} 
				;

attribute_id_chain ::=  ATTRIBUTE_ID:e1 {: RESULT = e1; :}
					  | attribute_id_chain:e1 DOT ATTRIBUTE_ID:e2  {: RESULT = e1+"."+e2; :}
					  ;

children_attribute_id ::=  SCHILDREN DOT attribute_id_chain:e1 {: RESULT = new ChildrenAttributeID("selectedchildren", e1); :}
                         | CHILDREN DOT attribute_id_chain:e1 {: RESULT = new ChildrenAttributeID("children", e1); :}
                         ;
                         
feature_id_list ::=  OPT FEATURE_ID:e1 {: RESULT = new FeatureIDList(true, e1); :}
				   | OPT FEATURE_ID:e1 COMMA feature_id_list:e2 {: RESULT = new FeatureIDList(true, e1, e2); :}
				   | FEATURE_ID:e1 {: RESULT = new FeatureIDList(false, e1); :}
				   | FEATURE_ID:e1 COMMA feature_id_list:e2 {: RESULT = new FeatureIDList(false, e1, e2); :}
				   ; 
					  
//----- Feature section ------------------------------------------------------------------------------------------ 
					  
fd ::=  ROOT FEATURE_ID:e1 {: parser.setRootFeatureID(e1); :}  CBRA data:e2 attributes:e3 constraints:e4 featuresGroup:e5 CBRAEND  feature:e6 {: RESULT = new Feature(false, e1,e2,e3,e4,e5,e6); :}
	  | ROOT FEATURE_ID:e1 {: parser.setRootFeatureID(e1); :} data:e2 attributes:e3 constraints:e4 featuresGroup:e5 feature:e6 {: RESULT = new Feature(false, e1,e2,e3,e4,e5,e6); :}
	  ;

featuresGroup ::=  {: RESULT = null; :}
			     | cardinality:e1 CBRA hierarchical_features:e2 CBRAEND {: RESULT = new FeaturesGroup(e1, e2); :}
			     | cardinality:e1 CBRA feature_id_list:e2 CBRAEND {: RESULT = new FeaturesGroup(e1, e2); :}
			;

feature ::=  
		   | OPT feature_id_path:e1 CBRA data:e2 attributes:e3 constraints:e4 featuresGroup:e5 CBRAEND feature:e6 {: RESULT = new Feature(true, e1.getPath(), e2, e3, e4, e5, e6); :}
		   | OPT feature_id_path:e1  data:e2 attributes:e3 constraints:e4 featuresGroup:e5 feature:e6 {: RESULT = new Feature(true, e1.getPath(), e2, e3, e4, e5, e6); :}
		   | feature_id_path:e1 CBRA data:e2 attributes:e3 constraints:e4 featuresGroup:e5 CBRAEND feature:e6 {: RESULT = new Feature(false, e1.getPath(), e2, e3, e4, e5, e6); :}
		   | feature_id_path:e1 data:e2 attributes:e3 constraints:e4 featuresGroup:e5 feature:e6 {: RESULT = new Feature(false, e1.getPath(), e2, e3, e4, e5, e6); :}
		   ;     

hierarchical_features ::=  hierarchical_feature:e1 {: RESULT = new HierarchicalFeatures(e1); :}
						 | hierarchical_feature:e1 hierarchical_features:e2 {: RESULT = new HierarchicalFeatures(e1, e2); :}
						 ;
						 
hierarchical_feature ::=  SHARED feature_id_path:e1 CBRA data:e2 CBRAEND {: RESULT = new HierarchicalFeature(false, true, e1.getPath(), e2); :}
					    | SHARED feature_id_path:e1 data:e2 {: RESULT = new HierarchicalFeature(false, true, e1.getPath(),e2); :}
					    | OPT FEATURE_ID:e1 CBRA data:e2 attributes:e3 constraints:e4 featuresGroup:e5 CBRAEND {: RESULT = new HierarchicalFeature(true, false, e1, e2, e3, e4, e5); :}
					    | OPT FEATURE_ID:e1 data:e2 attributes:e3 constraints:e4 featuresGroup:e5 {: RESULT = new HierarchicalFeature(true, false, e1, e2, e3, e4, e5); :}
					    | FEATURE_ID:e1 CBRA data:e2 attributes:e3 constraints:e4 featuresGroup:e5 CBRAEND {: RESULT = new HierarchicalFeature(false, false, e1, e2, e3, e4, e5); :}
					    | FEATURE_ID:e1 data:e2 attributes:e3 constraints:e4 featuresGroup:e5 {: RESULT = new HierarchicalFeature(false, false, e1, e2, e3, e4, e5); :}
					    ;
					  
cardinality ::=  GROUP ONEOF {: RESULT = new Cardinality("oneof"); :}
			   | GROUP SOMEOF {: RESULT = new Cardinality("someof"); :}
			   | GROUP ALLOF {: RESULT = new Cardinality("allof"); :}
			   | GROUP SQBRA ZERO DOT DOT ZERO SQBRAEND {: RESULT = new Cardinality("0","0"); :}
               | GROUP SQBRA ZERO DOT DOT INTEGER:e1 SQBRAEND {: RESULT = new Cardinality("0", e1); :}
               | GROUP SQBRA INTEGER:e1 DOT DOT INTEGER:e2 SQBRAEND {: RESULT = new Cardinality(e1, e2); :}
               | GROUP SQBRA INTEGER:e1 DOT DOT TIMES SQBRAEND {: RESULT = new Cardinality(e1, "*"); :}
               ;

//----- Attribute section ------------------------------------------------------------------------------------------
		
attributes ::=  {: RESULT = null; :}
			  | attribute:e1 attributes:e2 {: RESULT = new Attributes(e1, e2); :}
			  ;

attribute ::=  base_attribute:e1 {: RESULT = new Attribute(e1); :}
			 | ATTRIBUTE_ID:e1 ATTRIBUTE_ID:e2 ifin_ifout:e3 SEMICOLON {: RESULT = new Attribute(e1, e2, e3); :}
			 | ATTRIBUTE_ID:e1 ATTRIBUTE_ID:e2 CBRA struct_attribute_content:e3 CBRAEND SEMICOLON {: RESULT = new Attribute(e1, e2, e3); :}
			 | ATTRIBUTE_ID:e1 ATTRIBUTE_ID:e2 SEMICOLON {: RESULT = new Attribute(e1, e2); :}
			 ;
			
base_attribute ::=  INT ATTRIBUTE_ID:e1 SEMICOLON {: RESULT = new BaseAttribute("int", e1); :}
				  | INT ATTRIBUTE_ID:e1 IN set_expression:e2 COMMA ifin_ifout:e3 SEMICOLON  {: RESULT = new BaseAttribute("int", e1, e2, e3); :}
				  | INT ATTRIBUTE_ID:e1 IN set_expression:e2 SEMICOLON {: RESULT = new BaseAttribute("int", e1, e2); :}
				  | INT ATTRIBUTE_ID:e1 COMMA ifin_ifout:e2 SEMICOLON {: RESULT = new BaseAttribute("int", e1, e2); :}
				  | REALP ATTRIBUTE_ID:e1 SEMICOLON {: RESULT = new BaseAttribute("real", e1); :}
				  | REALP ATTRIBUTE_ID:e1 IN set_expression:e2 COMMA ifin_ifout:e3 SEMICOLON {: RESULT = new BaseAttribute("real", e1, e2, e3); :}
				  | REALP ATTRIBUTE_ID:e1 IN set_expression:e2 SEMICOLON {: RESULT = new BaseAttribute("real", e1, e2); :}
				  | REALP ATTRIBUTE_ID:e1 COMMA ifin_ifout:e2 SEMICOLON {: RESULT = new BaseAttribute("real", e1, e2); :}
				  | BOOL ATTRIBUTE_ID:e1 SEMICOLON {: RESULT = new BaseAttribute("bool", e1); :}
				  | BOOL ATTRIBUTE_ID:e1 COMMA ifin_ifout:e2 SEMICOLON {: RESULT = new BaseAttribute("bool", e1, e2); :}
				  | ENUM ATTRIBUTE_ID:e1 IN set_expression:e2 SEMICOLON {: RESULT = new BaseAttribute("enum", e1, e2); :}
				  | ENUM ATTRIBUTE_ID:e1 IN set_expression:e2 COMMA ifin_ifout:e3 SEMICOLON {: RESULT = new BaseAttribute("enum", e1, e2, e3); :}
				  ;
				  
ifin_ifout ::=  IFIN COLON expression:e1 COMMA IFOUT COLON expression:e2 {: RESULT = new IfInIfOut(e1, e2); :}
              | IFIN COLON expression:e1 COMMA IFOUT COLON IN set_expression:e2 {: RESULT = new IfInIfOut(e1, e2); :}
              | IFIN COLON IN set_expression:e1 COMMA IFOUT COLON expression:e2 {: RESULT = new IfInIfOut(e1, e2); :}
              | IFIN COLON IN set_expression:e1 COMMA IFOUT COLON IN set_expression:e2 {: RESULT = new IfInIfOut(e1, e2); :}
              | IFIN COLON expression:e1 {: RESULT = new IfInIfOut(true, e1); :}times
              | IFIN COLON IN set_expression:e1 {: RESULT = new IfInIfOut(true, e1); :}
              | IFOUT COLON expression:e1 {: RESULT = new IfInIfOut(false, e1); :}
              | IFOUT COLON IN set_expression:e1 {: RESULT = new IfInIfOut(false, e1); :}
              ;
			 
struct_attribute_content ::=  sub_attribute:e1 {: RESULT = new StructAttributeContent(e1); :}
							| sub_attribute:e1 struct_attribute_content:e2 {: RESULT = new StructAttributeContent(e1, e2); :}
							;
							 
sub_attribute ::=  ATTRIBUTE_ID:e1 COMMA ifin_ifout:e2 SEMICOLON {: RESULT = new SubAttribute(e1, e2); :}
				 ;

//----- Expression section ------------------------------------------------------------------------------------------

expression ::=  expression:e1 AND expression:e2 {: RESULT = new AndExpression(e1, e2); :}
 
			  | expression:e1 OR expression:e2 {: RESULT = new OrExpression(e1, e2); :} 
			  
			  | expression:e1 IMPLIES expression:e2 {: RESULT = new ImpliesExpression(e1, e2); :}
			  
			  | expression:e1 INVERSEIMPLIES expression:e2 {: RESULT = new InverseImpliesExpression(e1, e2); :}
			   
			  | expression:e1 IFANDONLYIF expression:e2 {: RESULT = new IfAndOnlyIfExpression(e1, e2); :} 
			  
			  | NOT BRA expression:e1 BRAEND {: RESULT = new NotExpression(e1); :}
			  
			  | BRA expression:e1 BRAEND {: RESULT = e1; :}
			  
			  | TRUE {: RESULT = new TrueExpression(); :}
			  
			  | FALSE {: RESULT = new FalseExpression(); :}
			  
		      | feature_id_path:e1 {: RESULT = new FeatureIDPathExpression(e1); :}
		      
			  | attribute_id_path:e1 {: RESULT = new AttributeIDPathExpression(e1); :}
			  
			  | expression:e1 EQUALS expression:e2 {: RESULT = new EqualsExpression(e1, e2); :}
			  
			  | expression:e1 NOTEQUALS expression:e2 {: RESULT = new NotEqualsExpression(e1, e2); :}
			  
			  | expression:e1 GEQ expression:e2 {: RESULT = new GEQExpression(e1, e2); :}
			  
			  | expression:e1 GREATER expression:e2 {: RESULT = new GreaterExpression(e1, e2); :}
			  
			  | expression:e1 LEQ expression:e2 {: RESULT = new LEQExpression(e1, e2); :}
			  
			  | expression:e1 LOWER expression:e2 {: RESULT = new LowerExpression(e1, e2); :}
			  
			  | expression:e1 IN set_expression:e2 {: RESULT = new InExpression(e1, e2); :}
			  
			  | ANDAGG BRA expression_list:e1 BRAEND {: RESULT = new AndAggExpression(e1); :}
			  
			  | ANDAGG BRA children_attribute_id:e1 BRAEND {: RESULT = new AndAggExpression(e1); :}
			  
			  | ORAGG BRA expression_list:e1 BRAEND {: RESULT = new OrAggExpression(e1); :}
			  
			  | ORAGG BRA children_attribute_id:e1 BRAEND {: RESULT = new OrAggExpression(e1); :}
			  
			  | XORAGG BRA expression_list:e1 BRAEND {: RESULT = new XorAggExpression(e1); :}
			  
			  | XORAGG BRA children_attribute_id:e1 BRAEND {: RESULT = new XorAggExpression(e1); :}
			  
			  | feature_id_path:e1 EXCLUDES feature_id_path:e2 {: RESULT = new ExcludesExpression(e1, e2); :}
			  
			  | feature_id_path:e1 REQUIRES feature_id_path:e2 {: RESULT = new IncludesExpression(e1, e2); :}
			  
			  | expression:e1 PLUS expression:e2 {: RESULT = new PlusExpression(e1, e2); :}
			  
			  | expression:e1 MINUS expression:e2 {: RESULT = new MinusExpression(e1, e2); :}
			  
			  | expression:e1 TIMES expression:e2 {: RESULT = new TimesExpression(e1, e2); :}
			  
			  | expression:e1 DIVIDE expression:e2 {: RESULT = new DivideExpression(e1, e2); :}
			  
			  | MINUS expression:e1 {: RESULT = new MinusExpression(e1); :} %prec UMINUS
			  
			  | ABS BRA expression:e1 BRAEND {: RESULT = new AbsExpression(e1); :}
			  
			  | QUEST expression:e1 COLON expression:e2 COMMA expression:e3 QUEST {: RESULT = new QuestExpression(e1, e2, e3); :}
			  
			  | SUM BRA expression_list:e1 BRAEND {: RESULT = new SumAggExpression(e1); :}
			  
			  | SUM BRA children_attribute_id:e1 BRAEND {: RESULT = new SumAggExpression(e1); :}
			  
			  | MUL BRA expression_list:e1 BRAEND {: RESULT = new MulAggExpression(e1); :}
			  
			  | MUL BRA children_attribute_id:e1 BRAEND {: RESULT = new MulAggExpression(e1); :}
			  
			  | MIN BRA expression_list:e1 BRAEND {: RESULT = new MinAggExpression(e1); :}
			  
			  | MIN BRA children_attribute_id:e1 BRAEND {: RESULT = new MinAggExpression(e1); :}
			  
			  | MAX BRA expression_list:e1 BRAEND {: RESULT = new MaxAggExpression(e1); :}
			  
			  | MAX BRA children_attribute_id:e1 BRAEND {: RESULT = new MaxAggExpression(e1); :}
			  
			  | COUNT BRA expression_list:e1 BRAEND {: RESULT = new CountAggExpression(e1); :}
			  
			  | COUNT BRA children_attribute_id:e1 BRAEND {: RESULT = new CountAggExpression(e1); :}
			  
			  | AVG BRA expression_list:e1 BRAEND {: RESULT = new AvgAggExpression(e1); :}
			  
			  | AVG BRA children_attribute_id:e1 BRAEND {: RESULT = new AvgAggExpression(e1); :}
			  
			  | ZERO {: RESULT = new ZeroExpression(); :}
			  
			  | INTEGER:e1 {: RESULT = new IntExpression(e1); :}
			  
			  | REAL:e1 {: RESULT = new RealExpression(e1); :}
			  ;

expression_list ::=  expression:e1 {: RESULT = new ExpressionList(e1); :}
			       | expression:e1 COMMA expression_list:e2 {: RESULT = new ExpressionList(e1, e2); :}
			       ;

set_expression ::=  CBRA expression_list:e1 CBRAEND {: RESULT = new SetExpression(e1); :}
				  | SQBRA INTEGER:e1 DOT DOT INTEGER:e2 SQBRAEND {: RESULT =  new SetExpression(e1, e2); :}
				  | SQBRA TIMES DOT DOT INTEGER:e1 SQBRAEND {: RESULT =  new SetExpression("times",e1); :}
				  | SQBRA INTEGER:e1 DOT DOT TIMES SQBRAEND {: RESULT =  new SetExpression(e1, "times"); :}
				  | SQBRA TIMES DOT DOT TIMES SQBRAEND {: RESULT =  new SetExpression("times", "times"); :}
				  | SQBRA REAL:e1 DOT DOT REAL:e2 SQBRAEND {: RESULT =  new SetExpression(e1, e2); :}
				  | SQBRA TIMES DOT DOT REAL:e1 SQBRAEND {: RESULT =  new SetExpression("times",e1); :}
				  | SQBRA REAL:e1 DOT DOT TIMES SQBRAEND {: RESULT =  new SetExpression(e1, "times"); :}
				  | SQBRA ZERO DOT DOT INTEGER:e1 SQBRAEND {: RESULT =  new SetExpression("0", e1); :}
				  | SQBRA INTEGER:e1 DOT DOT ZERO SQBRAEND {: RESULT =  new SetExpression(e1, "0"); :}
				  | SQBRA ZERO DOT DOT REAL:e1 {: RESULT =  new SetExpression("0", e1); :}
				  | SQBRA REAL:e1 DOT DOT ZERO SQBRAEND {: RESULT =  new SetExpression(e1, "0"); :}
				  | SQBRA TIMES DOT DOT ZERO SQBRAEND {: RESULT =  new SetExpression("times", "0"); :}
				  | SQBRA ZERO DOT DOT TIMES SQBRAEND {: RESULT =  new SetExpression("0", "times"); :}
				  ;
                   
//----- Constraint section ------------------------------------------------------------------------------------------
				  
constraints ::=  {: RESULT = null; :}
               | constraint:e1 constraints:e2 {: RESULT = new Constraints(e1, e2); :}
               ;
               
constraint ::=  IFIN COLON expression:e1 SEMICOLON {: RESULT = new Constraint(true, e1); :}
              | IFOUT COLON expression:e1 SEMICOLON {: RESULT = new Constraint(false, e1); :}
              ;
              
//----- Data section -------------------------------------------------------------------------------------------------

data ::=  {: RESULT = null; :}
		| DATA CBRA data_pair_list:e1 CBRAEND {: RESULT = new Data(e1); :}
		;
		
data_pair_list ::=  data_pair:e1 {: RESULT = new DataPairList(e1); :}
				  | data_pair:e1 SEMICOLON data_pair_list:e2 {: RESULT = new DataPairList(e1, e2); :}
				  ;
				  
data_pair ::= QUOT ATTRIBUTE_ID:e1 QUOT  QUOT ATTRIBUTE_ID:e2 QUOT {: RESULT = new DataPair(e1, e2); :}
			 ;	